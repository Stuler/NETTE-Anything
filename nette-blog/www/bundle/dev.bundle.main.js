/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/nette.config.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/nette.config.js":
/*!****************************!*\
  !*** ./js/nette.config.js ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var naja__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! naja */ \"./node_modules/naja/dist/Naja.esm.js\");\n // inicializace naja pro spracování ajax požadavků v nette\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  return naja__WEBPACK_IMPORTED_MODULE_0__[\"default\"].initialize({\n    history: false\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9uZXR0ZS5jb25maWcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9uZXR0ZS5jb25maWcuanM/NDg2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmFqYSBmcm9tICduYWphJztcblxuLy8gaW5pY2lhbGl6YWNlIG5hamEgcHJvIHNwcmFjb3bDoW7DrSBhamF4IHBvxb5hZGF2a8WvIHYgbmV0dGVcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiBuYWphLmluaXRpYWxpemUoe2hpc3Rvcnk6IGZhbHNlfSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/nette.config.js\n");

/***/ }),

/***/ "./node_modules/event-target-shim/index.js":
/*!*************************************************!*\
  !*** ./node_modules/event-target-shim/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * Assert a condition.\n * @param condition The condition that it should satisfy.\n * @param message The error message.\n * @param args The arguments for replacing placeholders in the message.\n */\nfunction assertType(condition, message, ...args) {\n    if (!condition) {\n        throw new TypeError(format(message, args));\n    }\n}\n/**\n * Convert a text and arguments to one string.\n * @param message The formating text\n * @param args The arguments.\n */\nfunction format(message, args) {\n    let i = 0;\n    return message.replace(/%[os]/gu, () => anyToString(args[i++]));\n}\n/**\n * Convert a value to a string representation.\n * @param x The value to get the string representation.\n */\nfunction anyToString(x) {\n    if (typeof x !== \"object\" || x === null) {\n        return String(x);\n    }\n    return Object.prototype.toString.call(x);\n}\n\nlet currentErrorHandler;\n/**\n * Set the error handler.\n * @param value The error handler to set.\n */\nfunction setErrorHandler(value) {\n    assertType(typeof value === \"function\" || value === undefined, \"The error handler must be a function or undefined, but got %o.\", value);\n    currentErrorHandler = value;\n}\n/**\n * Print a error message.\n * @param maybeError The error object.\n */\nfunction reportError(maybeError) {\n    try {\n        const error = maybeError instanceof Error\n            ? maybeError\n            : new Error(anyToString(maybeError));\n        // Call the user-defined error handler if exists.\n        if (currentErrorHandler) {\n            currentErrorHandler(error);\n            return;\n        }\n        // Dispatch an `error` event if this is on a browser.\n        if (typeof dispatchEvent === \"function\" &&\n            typeof ErrorEvent === \"function\") {\n            dispatchEvent(new ErrorEvent(\"error\", { error, message: error.message }));\n        }\n        // Emit an `uncaughtException` event if this is on Node.js.\n        //istanbul ignore else\n        else if (typeof process !== \"undefined\" &&\n            typeof process.emit === \"function\") {\n            process.emit(\"uncaughtException\", error);\n            return;\n        }\n        // Otherwise, print the error.\n        console.error(error);\n    }\n    catch (_a) {\n        // ignore.\n    }\n}\n\n/**\n * The global object.\n */\n//istanbul ignore next\nconst Global = typeof window !== \"undefined\"\n    ? window\n    : typeof self !== \"undefined\"\n        ? self\n        : typeof global !== \"undefined\"\n            ? global\n            : typeof globalThis !== \"undefined\"\n                ? globalThis\n                : undefined;\n\nlet currentWarnHandler;\n/**\n * Set the warning handler.\n * @param value The warning handler to set.\n */\nfunction setWarningHandler(value) {\n    assertType(typeof value === \"function\" || value === undefined, \"The warning handler must be a function or undefined, but got %o.\", value);\n    currentWarnHandler = value;\n}\n/**\n * The warning information.\n */\nclass Warning {\n    constructor(code, message) {\n        this.code = code;\n        this.message = message;\n    }\n    /**\n     * Report this warning.\n     * @param args The arguments of the warning.\n     */\n    warn(...args) {\n        var _a;\n        try {\n            // Call the user-defined warning handler if exists.\n            if (currentWarnHandler) {\n                currentWarnHandler({ ...this, args });\n                return;\n            }\n            // Otherwise, print the warning.\n            const stack = ((_a = new Error().stack) !== null && _a !== void 0 ? _a : \"\").replace(/^(?:.+?\\n){2}/gu, \"\\n\");\n            console.warn(this.message, ...args, stack);\n        }\n        catch (_b) {\n            // Ignore.\n        }\n    }\n}\n\nconst InitEventWasCalledWhileDispatching = new Warning(\"W01\", \"Unable to initialize event under dispatching.\");\nconst FalsyWasAssignedToCancelBubble = new Warning(\"W02\", \"Assigning any falsy value to 'cancelBubble' property has no effect.\");\nconst TruthyWasAssignedToReturnValue = new Warning(\"W03\", \"Assigning any truthy value to 'returnValue' property has no effect.\");\nconst NonCancelableEventWasCanceled = new Warning(\"W04\", \"Unable to preventDefault on non-cancelable events.\");\nconst CanceledInPassiveListener = new Warning(\"W05\", \"Unable to preventDefault inside passive event listener invocation.\");\nconst EventListenerWasDuplicated = new Warning(\"W06\", \"An event listener wasn't added because it has been added already: %o, %o\");\nconst OptionWasIgnored = new Warning(\"W07\", \"The %o option value was abandoned because the event listener wasn't added as duplicated.\");\nconst InvalidEventListener = new Warning(\"W08\", \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\");\nconst InvalidAttributeHandler = new Warning(\"W09\", \"Event attribute handler must be a function: %o\");\n\n/*eslint-disable class-methods-use-this */\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * `EventTarget` shim can control the internal state of this `Event` objects.\n * @see https://dom.spec.whatwg.org/#event\n */\nclass Event {\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    static get NONE() {\n        return NONE;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    static get CAPTURING_PHASE() {\n        return CAPTURING_PHASE;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    static get AT_TARGET() {\n        return AT_TARGET;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    static get BUBBLING_PHASE() {\n        return BUBBLING_PHASE;\n    }\n    /**\n     * Initialize this event instance.\n     * @param type The type of this event.\n     * @param eventInitDict Options to initialize.\n     * @see https://dom.spec.whatwg.org/#dom-event-event\n     */\n    constructor(type, eventInitDict) {\n        Object.defineProperty(this, \"isTrusted\", {\n            value: false,\n            enumerable: true,\n        });\n        const opts = eventInitDict !== null && eventInitDict !== void 0 ? eventInitDict : {};\n        internalDataMap.set(this, {\n            type: String(type),\n            bubbles: Boolean(opts.bubbles),\n            cancelable: Boolean(opts.cancelable),\n            composed: Boolean(opts.composed),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n            inPassiveListenerFlag: false,\n            dispatchFlag: false,\n            timeStamp: Date.now(),\n        });\n    }\n    /**\n     * The type of this event.\n     * @see https://dom.spec.whatwg.org/#dom-event-type\n     */\n    get type() {\n        return $(this).type;\n    }\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    get target() {\n        return $(this).target;\n    }\n    /**\n     * The event target of the current dispatching.\n     * @deprecated Use the `target` property instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-srcelement\n     */\n    get srcElement() {\n        return $(this).target;\n    }\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    get currentTarget() {\n        return $(this).currentTarget;\n    }\n    /**\n     * The event target of the current dispatching.\n     * This doesn't support node tree.\n     * @see https://dom.spec.whatwg.org/#dom-event-composedpath\n     */\n    composedPath() {\n        const currentTarget = $(this).currentTarget;\n        if (currentTarget) {\n            return [currentTarget];\n        }\n        return [];\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    get NONE() {\n        return NONE;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    get CAPTURING_PHASE() {\n        return CAPTURING_PHASE;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    get AT_TARGET() {\n        return AT_TARGET;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    get BUBBLING_PHASE() {\n        return BUBBLING_PHASE;\n    }\n    /**\n     * The current event phase.\n     * @see https://dom.spec.whatwg.org/#dom-event-eventphase\n     */\n    get eventPhase() {\n        return $(this).dispatchFlag ? 2 : 0;\n    }\n    /**\n     * Stop event bubbling.\n     * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.\n     * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation\n     */\n    stopPropagation() {\n        $(this).stopPropagationFlag = true;\n    }\n    /**\n     * `true` if event bubbling was stopped.\n     * @deprecated\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    get cancelBubble() {\n        return $(this).stopPropagationFlag;\n    }\n    /**\n     * Stop event bubbling if `true` is set.\n     * @deprecated Use the `stopPropagation()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    set cancelBubble(value) {\n        if (value) {\n            $(this).stopPropagationFlag = true;\n        }\n        else {\n            FalsyWasAssignedToCancelBubble.warn();\n        }\n    }\n    /**\n     * Stop event bubbling and subsequent event listener callings.\n     * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation\n     */\n    stopImmediatePropagation() {\n        const data = $(this);\n        data.stopPropagationFlag = data.stopImmediatePropagationFlag = true;\n    }\n    /**\n     * `true` if this event will bubble.\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbles\n     */\n    get bubbles() {\n        return $(this).bubbles;\n    }\n    /**\n     * `true` if this event can be canceled by the `preventDefault()` method.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelable\n     */\n    get cancelable() {\n        return $(this).cancelable;\n    }\n    /**\n     * `true` if the default behavior will act.\n     * @deprecated Use the `defaultPrevented` proeprty instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    get returnValue() {\n        return !$(this).canceledFlag;\n    }\n    /**\n     * Cancel the default behavior if `false` is set.\n     * @deprecated Use the `preventDefault()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag($(this));\n        }\n        else {\n            TruthyWasAssignedToReturnValue.warn();\n        }\n    }\n    /**\n     * Cancel the default behavior.\n     * @see https://dom.spec.whatwg.org/#dom-event-preventdefault\n     */\n    preventDefault() {\n        setCancelFlag($(this));\n    }\n    /**\n     * `true` if the default behavior was canceled.\n     * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented\n     */\n    get defaultPrevented() {\n        return $(this).canceledFlag;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    get composed() {\n        return $(this).composed;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-istrusted\n     */\n    //istanbul ignore next\n    get isTrusted() {\n        return false;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-timestamp\n     */\n    get timeStamp() {\n        return $(this).timeStamp;\n    }\n    /**\n     * @deprecated Don't use this method. The constructor did initialization.\n     */\n    initEvent(type, bubbles = false, cancelable = false) {\n        const data = $(this);\n        if (data.dispatchFlag) {\n            InitEventWasCalledWhileDispatching.warn();\n            return;\n        }\n        internalDataMap.set(this, {\n            ...data,\n            type: String(type),\n            bubbles: Boolean(bubbles),\n            cancelable: Boolean(cancelable),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n        });\n    }\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst NONE = 0;\nconst CAPTURING_PHASE = 1;\nconst AT_TARGET = 2;\nconst BUBBLING_PHASE = 3;\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap();\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(event, name = \"this\") {\n    const retv = internalDataMap.get(event);\n    assertType(retv != null, \"'%s' must be an object that Event constructor created, but got another one: %o\", name, event);\n    return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data private data.\n */\nfunction setCancelFlag(data) {\n    if (data.inPassiveListenerFlag) {\n        CanceledInPassiveListener.warn();\n        return;\n    }\n    if (!data.cancelable) {\n        NonCancelableEventWasCanceled.warn();\n        return;\n    }\n    data.canceledFlag = true;\n}\n// Set enumerable\nObject.defineProperty(Event, \"NONE\", { enumerable: true });\nObject.defineProperty(Event, \"CAPTURING_PHASE\", { enumerable: true });\nObject.defineProperty(Event, \"AT_TARGET\", { enumerable: true });\nObject.defineProperty(Event, \"BUBBLING_PHASE\", { enumerable: true });\nconst keys = Object.getOwnPropertyNames(Event.prototype);\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue;\n    }\n    Object.defineProperty(Event.prototype, keys[i], { enumerable: true });\n}\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, Global.Event.prototype);\n}\n\n/**\n * Create a new InvalidStateError instance.\n * @param message The error message.\n */\nfunction createInvalidStateError(message) {\n    if (Global.DOMException) {\n        return new Global.DOMException(message, \"InvalidStateError\");\n    }\n    if (DOMException == null) {\n        DOMException = class DOMException extends Error {\n            constructor(msg) {\n                super(msg);\n                if (Error.captureStackTrace) {\n                    Error.captureStackTrace(this, DOMException);\n                }\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get code() {\n                return 11;\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get name() {\n                return \"InvalidStateError\";\n            }\n        };\n        Object.defineProperties(DOMException.prototype, {\n            code: { enumerable: true },\n            name: { enumerable: true },\n        });\n        defineErrorCodeProperties(DOMException);\n        defineErrorCodeProperties(DOMException.prototype);\n    }\n    return new DOMException(message);\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nlet DOMException;\nconst ErrorCodeMap = {\n    INDEX_SIZE_ERR: 1,\n    DOMSTRING_SIZE_ERR: 2,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    INVALID_CHARACTER_ERR: 5,\n    NO_DATA_ALLOWED_ERR: 6,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INUSE_ATTRIBUTE_ERR: 10,\n    INVALID_STATE_ERR: 11,\n    SYNTAX_ERR: 12,\n    INVALID_MODIFICATION_ERR: 13,\n    NAMESPACE_ERR: 14,\n    INVALID_ACCESS_ERR: 15,\n    VALIDATION_ERR: 16,\n    TYPE_MISMATCH_ERR: 17,\n    SECURITY_ERR: 18,\n    NETWORK_ERR: 19,\n    ABORT_ERR: 20,\n    URL_MISMATCH_ERR: 21,\n    QUOTA_EXCEEDED_ERR: 22,\n    TIMEOUT_ERR: 23,\n    INVALID_NODE_TYPE_ERR: 24,\n    DATA_CLONE_ERR: 25,\n};\nfunction defineErrorCodeProperties(obj) {\n    const keys = Object.keys(ErrorCodeMap);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = ErrorCodeMap[key];\n        Object.defineProperty(obj, key, {\n            get() {\n                return value;\n            },\n            configurable: true,\n            enumerable: true,\n        });\n    }\n}\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * This class controls the internal state of `Event`.\n * @see https://dom.spec.whatwg.org/#interface-event\n */\nclass EventWrapper extends Event {\n    /**\n     * Wrap a given event object to control states.\n     * @param event The event-like object to wrap.\n     */\n    static wrap(event) {\n        return new (getWrapperClassOf(event))(event);\n    }\n    constructor(event) {\n        super(event.type, {\n            bubbles: event.bubbles,\n            cancelable: event.cancelable,\n            composed: event.composed,\n        });\n        if (event.cancelBubble) {\n            super.stopPropagation();\n        }\n        if (event.defaultPrevented) {\n            super.preventDefault();\n        }\n        internalDataMap$1.set(this, { original: event });\n        // Define accessors\n        const keys = Object.keys(event);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            if (!(key in this)) {\n                Object.defineProperty(this, key, defineRedirectDescriptor(event, key));\n            }\n        }\n    }\n    stopPropagation() {\n        super.stopPropagation();\n        const { original } = $$1(this);\n        if (\"stopPropagation\" in original) {\n            original.stopPropagation();\n        }\n    }\n    get cancelBubble() {\n        return super.cancelBubble;\n    }\n    set cancelBubble(value) {\n        super.cancelBubble = value;\n        const { original } = $$1(this);\n        if (\"cancelBubble\" in original) {\n            original.cancelBubble = value;\n        }\n    }\n    stopImmediatePropagation() {\n        super.stopImmediatePropagation();\n        const { original } = $$1(this);\n        if (\"stopImmediatePropagation\" in original) {\n            original.stopImmediatePropagation();\n        }\n    }\n    get returnValue() {\n        return super.returnValue;\n    }\n    set returnValue(value) {\n        super.returnValue = value;\n        const { original } = $$1(this);\n        if (\"returnValue\" in original) {\n            original.returnValue = value;\n        }\n    }\n    preventDefault() {\n        super.preventDefault();\n        const { original } = $$1(this);\n        if (\"preventDefault\" in original) {\n            original.preventDefault();\n        }\n    }\n    get timeStamp() {\n        const { original } = $$1(this);\n        if (\"timeStamp\" in original) {\n            return original.timeStamp;\n        }\n        return super.timeStamp;\n    }\n}\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap$1 = new WeakMap();\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @returns The private data of the event.\n */\nfunction $$1(event) {\n    const retv = internalDataMap$1.get(event);\n    assertType(retv != null, \"'this' is expected an Event object, but got\", event);\n    return retv;\n}\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrapperClassCache = new WeakMap();\n// Make association for wrappers.\nwrapperClassCache.set(Object.prototype, EventWrapper);\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    wrapperClassCache.set(Global.Event.prototype, EventWrapper);\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param originalEvent The event object to wrap.\n */\nfunction getWrapperClassOf(originalEvent) {\n    const prototype = Object.getPrototypeOf(originalEvent);\n    if (prototype == null) {\n        return EventWrapper;\n    }\n    let wrapper = wrapperClassCache.get(prototype);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapperClassOf(prototype), prototype);\n        wrapperClassCache.set(prototype, wrapper);\n    }\n    return wrapper;\n}\n/**\n * Define new wrapper class.\n * @param BaseEventWrapper The base wrapper class.\n * @param originalPrototype The prototype of the original event.\n */\nfunction defineWrapper(BaseEventWrapper, originalPrototype) {\n    class CustomEventWrapper extends BaseEventWrapper {\n    }\n    const keys = Object.keys(originalPrototype);\n    for (let i = 0; i < keys.length; ++i) {\n        Object.defineProperty(CustomEventWrapper.prototype, keys[i], defineRedirectDescriptor(originalPrototype, keys[i]));\n    }\n    return CustomEventWrapper;\n}\n/**\n * Get the property descriptor to redirect a given property.\n */\nfunction defineRedirectDescriptor(obj, key) {\n    const d = Object.getOwnPropertyDescriptor(obj, key);\n    return {\n        get() {\n            const original = $$1(this).original;\n            const value = original[key];\n            if (typeof value === \"function\") {\n                return value.bind(original);\n            }\n            return value;\n        },\n        set(value) {\n            const original = $$1(this).original;\n            original[key] = value;\n        },\n        configurable: d.configurable,\n        enumerable: d.enumerable,\n    };\n}\n\n/**\n * Create a new listener.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n * @param signalListener The abort event listener for the abort signal.\n */\nfunction createListener(callback, capture, passive, once, signal, signalListener) {\n    return {\n        callback,\n        flags: (capture ? 1 /* Capture */ : 0) |\n            (passive ? 2 /* Passive */ : 0) |\n            (once ? 4 /* Once */ : 0),\n        signal,\n        signalListener,\n    };\n}\n/**\n * Set the `removed` flag to the given listener.\n * @param listener The listener to check.\n */\nfunction setRemoved(listener) {\n    listener.flags |= 8 /* Removed */;\n}\n/**\n * Check if the given listener has the `capture` flag or not.\n * @param listener The listener to check.\n */\nfunction isCapture(listener) {\n    return (listener.flags & 1 /* Capture */) === 1 /* Capture */;\n}\n/**\n * Check if the given listener has the `passive` flag or not.\n * @param listener The listener to check.\n */\nfunction isPassive(listener) {\n    return (listener.flags & 2 /* Passive */) === 2 /* Passive */;\n}\n/**\n * Check if the given listener has the `once` flag or not.\n * @param listener The listener to check.\n */\nfunction isOnce(listener) {\n    return (listener.flags & 4 /* Once */) === 4 /* Once */;\n}\n/**\n * Check if the given listener has the `removed` flag or not.\n * @param listener The listener to check.\n */\nfunction isRemoved(listener) {\n    return (listener.flags & 8 /* Removed */) === 8 /* Removed */;\n}\n/**\n * Call an event listener.\n * @param listener The listener to call.\n * @param target The event target object for `thisArg`.\n * @param event The event object for the first argument.\n * @param attribute `true` if this callback is an event attribute handler.\n */\nfunction invokeCallback({ callback }, target, event) {\n    try {\n        if (typeof callback === \"function\") {\n            callback.call(target, event);\n        }\n        else if (typeof callback.handleEvent === \"function\") {\n            callback.handleEvent(event);\n        }\n    }\n    catch (thrownError) {\n        reportError(thrownError);\n    }\n}\n\n/**\n * Find the index of given listener.\n * This returns `-1` if not found.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n */\nfunction findIndexOfListener({ listeners }, callback, capture) {\n    for (let i = 0; i < listeners.length; ++i) {\n        if (listeners[i].callback === callback &&\n            isCapture(listeners[i]) === capture) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Add the given listener.\n * Does copy-on-write if needed.\n * @param list The listener list.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n */\nfunction addListener(list, callback, capture, passive, once, signal) {\n    let signalListener;\n    if (signal) {\n        signalListener = removeListener.bind(null, list, callback, capture);\n        signal.addEventListener(\"abort\", signalListener);\n    }\n    const listener = createListener(callback, capture, passive, once, signal, signalListener);\n    if (list.cow) {\n        list.cow = false;\n        list.listeners = [...list.listeners, listener];\n    }\n    else {\n        list.listeners.push(listener);\n    }\n    return listener;\n}\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n * @returns `true` if it mutated the list directly.\n */\nfunction removeListener(list, callback, capture) {\n    const index = findIndexOfListener(list, callback, capture);\n    if (index !== -1) {\n        return removeListenerAt(list, index);\n    }\n    return false;\n}\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param index The index of the target listener.\n * @param disableCow Disable copy-on-write if true.\n * @returns `true` if it mutated the `listeners` array directly.\n */\nfunction removeListenerAt(list, index, disableCow = false) {\n    const listener = list.listeners[index];\n    // Set the removed flag.\n    setRemoved(listener);\n    // Dispose the abort signal listener if exists.\n    if (listener.signal) {\n        listener.signal.removeEventListener(\"abort\", listener.signalListener);\n    }\n    // Remove it from the array.\n    if (list.cow && !disableCow) {\n        list.cow = false;\n        list.listeners = list.listeners.filter((_, i) => i !== index);\n        return false;\n    }\n    list.listeners.splice(index, 1);\n    return true;\n}\n\n/**\n * Create a new `ListenerListMap` object.\n */\nfunction createListenerListMap() {\n    return Object.create(null);\n}\n/**\n * Get the listener list of the given type.\n * If the listener list has not been initialized, initialize and return it.\n * @param listenerMap The listener list map.\n * @param type The event type to get.\n */\nfunction ensureListenerList(listenerMap, type) {\n    var _a;\n    return ((_a = listenerMap[type]) !== null && _a !== void 0 ? _a : (listenerMap[type] = {\n        attrCallback: undefined,\n        attrListener: undefined,\n        cow: false,\n        listeners: [],\n    }));\n}\n\n/**\n * An implementation of the `EventTarget` interface.\n * @see https://dom.spec.whatwg.org/#eventtarget\n */\nclass EventTarget {\n    /**\n     * Initialize this instance.\n     */\n    constructor() {\n        internalDataMap$2.set(this, createListenerListMap());\n    }\n    // Implementation\n    addEventListener(type0, callback0, options0) {\n        const listenerMap = $$2(this);\n        const { callback, capture, once, passive, signal, type, } = normalizeAddOptions(type0, callback0, options0);\n        if (callback == null || (signal === null || signal === void 0 ? void 0 : signal.aborted)) {\n            return;\n        }\n        const list = ensureListenerList(listenerMap, type);\n        // Find existing listener.\n        const i = findIndexOfListener(list, callback, capture);\n        if (i !== -1) {\n            warnDuplicate(list.listeners[i], passive, once, signal);\n            return;\n        }\n        // Add the new listener.\n        addListener(list, callback, capture, passive, once, signal);\n    }\n    // Implementation\n    removeEventListener(type0, callback0, options0) {\n        const listenerMap = $$2(this);\n        const { callback, capture, type } = normalizeOptions(type0, callback0, options0);\n        const list = listenerMap[type];\n        if (callback != null && list) {\n            removeListener(list, callback, capture);\n        }\n    }\n    // Implementation\n    dispatchEvent(e) {\n        const list = $$2(this)[String(e.type)];\n        if (list == null) {\n            return true;\n        }\n        const event = e instanceof Event ? e : EventWrapper.wrap(e);\n        const eventData = $(event, \"event\");\n        if (eventData.dispatchFlag) {\n            throw createInvalidStateError(\"This event has been in dispatching.\");\n        }\n        eventData.dispatchFlag = true;\n        eventData.target = eventData.currentTarget = this;\n        if (!eventData.stopPropagationFlag) {\n            const { cow, listeners } = list;\n            // Set copy-on-write flag.\n            list.cow = true;\n            // Call listeners.\n            for (let i = 0; i < listeners.length; ++i) {\n                const listener = listeners[i];\n                // Skip if removed.\n                if (isRemoved(listener)) {\n                    continue;\n                }\n                // Remove this listener if has the `once` flag.\n                if (isOnce(listener) && removeListenerAt(list, i, !cow)) {\n                    // Because this listener was removed, the next index is the\n                    // same as the current value.\n                    i -= 1;\n                }\n                // Call this listener with the `passive` flag.\n                eventData.inPassiveListenerFlag = isPassive(listener);\n                invokeCallback(listener, this, event);\n                eventData.inPassiveListenerFlag = false;\n                // Stop if the `event.stopImmediatePropagation()` method was called.\n                if (eventData.stopImmediatePropagationFlag) {\n                    break;\n                }\n            }\n            // Restore copy-on-write flag.\n            if (!cow) {\n                list.cow = false;\n            }\n        }\n        eventData.target = null;\n        eventData.currentTarget = null;\n        eventData.stopImmediatePropagationFlag = false;\n        eventData.stopPropagationFlag = false;\n        eventData.dispatchFlag = false;\n        return !eventData.canceledFlag;\n    }\n}\n/**\n * Internal data.\n */\nconst internalDataMap$2 = new WeakMap();\n/**\n * Get private data.\n * @param target The event target object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $$2(target, name = \"this\") {\n    const retv = internalDataMap$2.get(target);\n    assertType(retv != null, \"'%s' must be an object that EventTarget constructor created, but got another one: %o\", name, target);\n    return retv;\n}\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeAddOptions(type, callback, options) {\n    var _a;\n    assertCallback(callback);\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback !== null && callback !== void 0 ? callback : undefined,\n            capture: Boolean(options.capture),\n            passive: Boolean(options.passive),\n            once: Boolean(options.once),\n            signal: (_a = options.signal) !== null && _a !== void 0 ? _a : undefined,\n        };\n    }\n    return {\n        type: String(type),\n        callback: callback !== null && callback !== void 0 ? callback : undefined,\n        capture: Boolean(options),\n        passive: false,\n        once: false,\n        signal: undefined,\n    };\n}\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeOptions(type, callback, options) {\n    assertCallback(callback);\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback !== null && callback !== void 0 ? callback : undefined,\n            capture: Boolean(options.capture),\n        };\n    }\n    return {\n        type: String(type),\n        callback: callback !== null && callback !== void 0 ? callback : undefined,\n        capture: Boolean(options),\n    };\n}\n/**\n * Assert the type of 'callback' argument.\n * @param callback The callback to check.\n */\nfunction assertCallback(callback) {\n    if (typeof callback === \"function\" ||\n        (typeof callback === \"object\" &&\n            callback !== null &&\n            typeof callback.handleEvent === \"function\")) {\n        return;\n    }\n    if (callback == null || typeof callback === \"object\") {\n        InvalidEventListener.warn(callback);\n        return;\n    }\n    throw new TypeError(format(InvalidEventListener.message, [callback]));\n}\n/**\n * Print warning for duplicated.\n * @param listener The current listener that is duplicated.\n * @param passive The passive flag of the new duplicated listener.\n * @param once The once flag of the new duplicated listener.\n * @param signal The signal object of the new duplicated listener.\n */\nfunction warnDuplicate(listener, passive, once, signal) {\n    EventListenerWasDuplicated.warn(isCapture(listener) ? \"capture\" : \"bubble\", listener.callback);\n    if (isPassive(listener) !== passive) {\n        OptionWasIgnored.warn(\"passive\");\n    }\n    if (isOnce(listener) !== once) {\n        OptionWasIgnored.warn(\"once\");\n    }\n    if (listener.signal !== signal) {\n        OptionWasIgnored.warn(\"signal\");\n    }\n}\n// Set enumerable\nconst keys$1 = Object.getOwnPropertyNames(EventTarget.prototype);\nfor (let i = 0; i < keys$1.length; ++i) {\n    if (keys$1[i] === \"constructor\") {\n        continue;\n    }\n    Object.defineProperty(EventTarget.prototype, keys$1[i], { enumerable: true });\n}\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (typeof Global !== \"undefined\" &&\n    typeof Global.EventTarget !== \"undefined\") {\n    Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype);\n}\n\n/**\n * Get the current value of a given event attribute.\n * @param target The `EventTarget` object to get.\n * @param type The event type.\n */\nfunction getEventAttributeValue(target, type) {\n    var _a, _b;\n    const listMap = $$2(target, \"target\");\n    return (_b = (_a = listMap[type]) === null || _a === void 0 ? void 0 : _a.attrCallback) !== null && _b !== void 0 ? _b : null;\n}\n/**\n * Set an event listener to a given event attribute.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction setEventAttributeValue(target, type, callback) {\n    if (callback != null && typeof callback !== \"function\") {\n        InvalidAttributeHandler.warn(callback);\n    }\n    if (typeof callback === \"function\" ||\n        (typeof callback === \"object\" && callback !== null)) {\n        upsertEventAttributeListener(target, type, callback);\n    }\n    else {\n        removeEventAttributeListener(target, type);\n    }\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n/**\n * Update or insert the given event attribute handler.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction upsertEventAttributeListener(target, type, callback) {\n    const list = ensureListenerList($$2(target, \"target\"), String(type));\n    list.attrCallback = callback;\n    if (list.attrListener == null) {\n        list.attrListener = addListener(list, defineEventAttributeCallback(list), false, false, false, undefined);\n    }\n}\n/**\n * Remove the given event attribute handler.\n * @param target The `EventTarget` object to remove.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction removeEventAttributeListener(target, type) {\n    const listMap = $$2(target, \"target\");\n    const list = listMap[String(type)];\n    if (list && list.attrListener) {\n        removeListener(list, list.attrListener.callback, false);\n        list.attrCallback = list.attrListener = undefined;\n    }\n}\n/**\n * Define the callback function for the given listener list object.\n * It calls `attrCallback` property if the property value is a function.\n * @param list The `ListenerList` object.\n */\nfunction defineEventAttributeCallback(list) {\n    return function (event) {\n        const callback = list.attrCallback;\n        if (typeof callback === \"function\") {\n            callback.call(this, event);\n        }\n    };\n}\n\n/**\n * Define an `EventTarget` class that has event attibutes.\n * @param types The types to define event attributes.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nfunction defineCustomEventTarget(...types) {\n    class CustomEventTarget extends EventTarget {\n    }\n    for (let i = 0; i < types.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, types[i]);\n    }\n    return CustomEventTarget;\n}\n/**\n * Define an event attribute.\n * @param target The `EventTarget` object to define an event attribute.\n * @param type The event type to define.\n * @param _eventClass Unused, but to infer `Event` class type.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nfunction defineEventAttribute(target, type, _eventClass) {\n    Object.defineProperty(target, `on${type}`, {\n        get() {\n            return getEventAttributeValue(this, type);\n        },\n        set(value) {\n            setEventAttributeValue(this, type, value);\n        },\n        configurable: true,\n        enumerable: true,\n    });\n}\n\nexports.Event = Event;\nexports.EventTarget = EventTarget;\nexports.default = EventTarget;\nexports.defineCustomEventTarget = defineCustomEventTarget;\nexports.defineEventAttribute = defineEventAttribute;\nexports.getEventAttributeValue = getEventAttributeValue;\nexports.setErrorHandler = setErrorHandler;\nexports.setEventAttributeValue = setEventAttributeValue;\nexports.setWarningHandler = setWarningHandler;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnQtdGFyZ2V0LXNoaW0vaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2xpYi9taXNjLnRzPzk4MDgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9saWIvZXJyb3ItaGFuZGxlci50cz9hNGNkIiwid2VicGFjazovLy8uLi9zcmMvbGliL2dsb2JhbC50cz85NTFjIiwid2VicGFjazovLy8uLi9zcmMvbGliL3dhcm5pbmctaGFuZGxlci50cz81YzI1Iiwid2VicGFjazovLy8uLi9zcmMvbGliL3dhcm5pbmdzLnRzP2YwOTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9saWIvZXZlbnQudHM/MmNjZCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xpYi9kb20tZXhjZXB0aW9uLnRzPzk2YmUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9saWIvZXZlbnQtd3JhcHBlci50cz8zOGNkIiwid2VicGFjazovLy8uLi9zcmMvbGliL2xpc3RlbmVyLnRzPzc0ZTIiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9saWIvbGlzdGVuZXItbGlzdC50cz9lNmMyIiwid2VicGFjazovLy8uLi9zcmMvbGliL2xpc3RlbmVyLWxpc3QtbWFwLnRzPzNlZjUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9saWIvZXZlbnQtdGFyZ2V0LnRzPzQ0NGIiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9saWIvZXZlbnQtYXR0cmlidXRlLWhhbmRsZXIudHM/ZGNmOSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xpYi9sZWdhY3kudHM/NzIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFzc2VydCBhIGNvbmRpdGlvbi5cbiAqIEBwYXJhbSBjb25kaXRpb24gVGhlIGNvbmRpdGlvbiB0aGF0IGl0IHNob3VsZCBzYXRpc2Z5LlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzIGZvciByZXBsYWNpbmcgcGxhY2Vob2xkZXJzIGluIHRoZSBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VHlwZShcbiAgICBjb25kaXRpb246IGJvb2xlYW4sXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIC4uLmFyZ3M6IGFueVtdXG4pOiBhc3NlcnRzIGNvbmRpdGlvbiB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmb3JtYXQobWVzc2FnZSwgYXJncykpXG4gICAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB0ZXh0IGFuZCBhcmd1bWVudHMgdG8gb25lIHN0cmluZy5cbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBmb3JtYXRpbmcgdGV4dFxuICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChtZXNzYWdlOiBzdHJpbmcsIGFyZ3M6IGFueVtdKTogc3RyaW5nIHtcbiAgICBsZXQgaSA9IDBcbiAgICByZXR1cm4gbWVzc2FnZS5yZXBsYWNlKC8lW29zXS9ndSwgKCkgPT4gYW55VG9TdHJpbmcoYXJnc1tpKytdKSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gZ2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbnlUb1N0cmluZyh4OiBhbnkpOiBzdHJpbmcge1xuICAgIGlmICh0eXBlb2YgeCAhPT0gXCJvYmplY3RcIiB8fCB4ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoeClcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KVxufVxuIiwiaW1wb3J0IHsgYW55VG9TdHJpbmcsIGFzc2VydFR5cGUgfSBmcm9tIFwiLi9taXNjXCJcblxuZGVjbGFyZSBjb25zdCBjb25zb2xlOiBhbnlcbmRlY2xhcmUgY29uc3QgZGlzcGF0Y2hFdmVudDogYW55XG5kZWNsYXJlIGNvbnN0IEVycm9yRXZlbnQ6IGFueVxuZGVjbGFyZSBjb25zdCBwcm9jZXNzOiBhbnlcblxubGV0IGN1cnJlbnRFcnJvckhhbmRsZXI6IHNldEVycm9ySGFuZGxlci5FcnJvckhhbmRsZXIgfCB1bmRlZmluZWRcblxuLyoqXG4gKiBTZXQgdGhlIGVycm9yIGhhbmRsZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGVycm9yIGhhbmRsZXIgdG8gc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RXJyb3JIYW5kbGVyKFxuICAgIHZhbHVlOiBzZXRFcnJvckhhbmRsZXIuRXJyb3JIYW5kbGVyIHwgdW5kZWZpbmVkLFxuKTogdm9pZCB7XG4gICAgYXNzZXJ0VHlwZShcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCxcbiAgICAgICAgXCJUaGUgZXJyb3IgaGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgdW5kZWZpbmVkLCBidXQgZ290ICVvLlwiLFxuICAgICAgICB2YWx1ZSxcbiAgICApXG4gICAgY3VycmVudEVycm9ySGFuZGxlciA9IHZhbHVlXG59XG5leHBvcnQgbmFtZXNwYWNlIHNldEVycm9ySGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogVGhlIGVycm9yIGhhbmRsZXIuXG4gICAgICogQHBhcmFtIGVycm9yIFRoZSB0aHJvd24gZXJyb3Igb2JqZWN0LlxuICAgICAqL1xuICAgIGV4cG9ydCB0eXBlIEVycm9ySGFuZGxlciA9IChlcnJvcjogRXJyb3IpID0+IHZvaWRcbn1cblxuLyoqXG4gKiBQcmludCBhIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0gbWF5YmVFcnJvciBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0RXJyb3IobWF5YmVFcnJvcjogdW5rbm93bik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVycm9yID1cbiAgICAgICAgICAgIG1heWJlRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgICAgID8gbWF5YmVFcnJvclxuICAgICAgICAgICAgICAgIDogbmV3IEVycm9yKGFueVRvU3RyaW5nKG1heWJlRXJyb3IpKVxuXG4gICAgICAgIC8vIENhbGwgdGhlIHVzZXItZGVmaW5lZCBlcnJvciBoYW5kbGVyIGlmIGV4aXN0cy5cbiAgICAgICAgaWYgKGN1cnJlbnRFcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIGN1cnJlbnRFcnJvckhhbmRsZXIoZXJyb3IpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGFuIGBlcnJvcmAgZXZlbnQgaWYgdGhpcyBpcyBvbiBhIGJyb3dzZXIuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBkaXNwYXRjaEV2ZW50ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBFcnJvckV2ZW50ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvckV2ZW50KFwiZXJyb3JcIiwgeyBlcnJvciwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB9KSxcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVtaXQgYW4gYHVuY2F1Z2h0RXhjZXB0aW9uYCBldmVudCBpZiB0aGlzIGlzIG9uIE5vZGUuanMuXG4gICAgICAgIC8vaXN0YW5idWwgaWdub3JlIGVsc2VcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwidW5jYXVnaHRFeGNlcHRpb25cIiwgZXJyb3IpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgcHJpbnQgdGhlIGVycm9yLlxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBpZ25vcmUuXG4gICAgfVxufVxuIiwiZGVjbGFyZSBjb25zdCBnbG9iYWxUaGlzOiBhbnlcbmRlY2xhcmUgY29uc3Qgd2luZG93OiBhbnlcbmRlY2xhcmUgY29uc3Qgc2VsZjogYW55XG5kZWNsYXJlIGNvbnN0IGdsb2JhbDogYW55XG5cbi8qKlxuICogVGhlIGdsb2JhbCBvYmplY3QuXG4gKi9cbi8vaXN0YW5idWwgaWdub3JlIG5leHRcbmV4cG9ydCBjb25zdCBHbG9iYWw6IGFueSA9XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgID8gc2VsZlxuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICA/IGdsb2JhbFRoaXNcbiAgICAgICAgOiB1bmRlZmluZWRcbiIsImltcG9ydCB7IGFzc2VydFR5cGUgfSBmcm9tIFwiLi9taXNjXCJcblxuZGVjbGFyZSBjb25zdCBjb25zb2xlOiBhbnlcblxubGV0IGN1cnJlbnRXYXJuSGFuZGxlcjogc2V0V2FybmluZ0hhbmRsZXIuV2FybmluZ0hhbmRsZXIgfCB1bmRlZmluZWRcblxuLyoqXG4gKiBTZXQgdGhlIHdhcm5pbmcgaGFuZGxlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgd2FybmluZyBoYW5kbGVyIHRvIHNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFdhcm5pbmdIYW5kbGVyKFxuICAgIHZhbHVlOiBzZXRXYXJuaW5nSGFuZGxlci5XYXJuaW5nSGFuZGxlciB8IHVuZGVmaW5lZCxcbik6IHZvaWQge1xuICAgIGFzc2VydFR5cGUoXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHZhbHVlID09PSB1bmRlZmluZWQsXG4gICAgICAgIFwiVGhlIHdhcm5pbmcgaGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgdW5kZWZpbmVkLCBidXQgZ290ICVvLlwiLFxuICAgICAgICB2YWx1ZSxcbiAgICApXG4gICAgY3VycmVudFdhcm5IYW5kbGVyID0gdmFsdWVcbn1cbmV4cG9ydCBuYW1lc3BhY2Ugc2V0V2FybmluZ0hhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIFRoZSB3YXJuaW5nIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgV2FybmluZyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29kZSBvZiB0aGlzIHdhcm5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBjb2RlOiBzdHJpbmdcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtZXNzYWdlIGluIEVuZ2xpc2guXG4gICAgICAgICAqL1xuICAgICAgICBtZXNzYWdlOiBzdHJpbmdcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcmd1bWVudHMgZm9yIHJlcGxhY2luZyBwbGFjZWhvbGRlcnMgaW4gdGhlIHRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBhcmdzOiBhbnlbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB3YXJuaW5nIGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHdhcm5pbmcgVGhlIHdhcm5pbmcuXG4gICAgICovXG4gICAgZXhwb3J0IHR5cGUgV2FybmluZ0hhbmRsZXIgPSAod2FybmluZzogV2FybmluZykgPT4gdm9pZFxufVxuXG4vKipcbiAqIFRoZSB3YXJuaW5nIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgV2FybmluZzxUQXJncyBleHRlbmRzIGFueVtdPiB7XG4gICAgcmVhZG9ubHkgY29kZTogc3RyaW5nXG4gICAgcmVhZG9ubHkgbWVzc2FnZTogc3RyaW5nXG5cbiAgICBjb25zdHJ1Y3Rvcihjb2RlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZykge1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgdGhpcyB3YXJuaW5nLlxuICAgICAqIEBwYXJhbSBhcmdzIFRoZSBhcmd1bWVudHMgb2YgdGhlIHdhcm5pbmcuXG4gICAgICovXG4gICAgd2FybiguLi5hcmdzOiBUQXJncyk6IHZvaWQge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdXNlci1kZWZpbmVkIHdhcm5pbmcgaGFuZGxlciBpZiBleGlzdHMuXG4gICAgICAgICAgICBpZiAoY3VycmVudFdhcm5IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFdhcm5IYW5kbGVyKHsgLi4udGhpcywgYXJncyB9KVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHByaW50IHRoZSB3YXJuaW5nLlxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSAobmV3IEVycm9yKCkuc3RhY2sgPz8gXCJcIikucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvXig/Oi4rP1xcbil7Mn0vZ3UsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLm1lc3NhZ2UsIC4uLmFyZ3MsIHN0YWNrKVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIElnbm9yZS5cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50VGFyZ2V0IH0gZnJvbSBcIi4vZXZlbnQtdGFyZ2V0XCIgLy8gVXNlZCBhcyBvbmx5IHR5cGUsIHNvIG5vIGNpcmN1bGFyLlxuaW1wb3J0IHsgV2FybmluZyB9IGZyb20gXCIuL3dhcm5pbmctaGFuZGxlclwiXG5cbmV4cG9ydCBjb25zdCBJbml0RXZlbnRXYXNDYWxsZWRXaGlsZURpc3BhdGNoaW5nID0gbmV3IFdhcm5pbmc8W10+KFxuICAgIFwiVzAxXCIsXG4gICAgXCJVbmFibGUgdG8gaW5pdGlhbGl6ZSBldmVudCB1bmRlciBkaXNwYXRjaGluZy5cIixcbilcblxuZXhwb3J0IGNvbnN0IEZhbHN5V2FzQXNzaWduZWRUb0NhbmNlbEJ1YmJsZSA9IG5ldyBXYXJuaW5nPFtdPihcbiAgICBcIlcwMlwiLFxuICAgIFwiQXNzaWduaW5nIGFueSBmYWxzeSB2YWx1ZSB0byAnY2FuY2VsQnViYmxlJyBwcm9wZXJ0eSBoYXMgbm8gZWZmZWN0LlwiLFxuKVxuXG5leHBvcnQgY29uc3QgVHJ1dGh5V2FzQXNzaWduZWRUb1JldHVyblZhbHVlID0gbmV3IFdhcm5pbmc8W10+KFxuICAgIFwiVzAzXCIsXG4gICAgXCJBc3NpZ25pbmcgYW55IHRydXRoeSB2YWx1ZSB0byAncmV0dXJuVmFsdWUnIHByb3BlcnR5IGhhcyBubyBlZmZlY3QuXCIsXG4pXG5cbmV4cG9ydCBjb25zdCBOb25DYW5jZWxhYmxlRXZlbnRXYXNDYW5jZWxlZCA9IG5ldyBXYXJuaW5nPFtdPihcbiAgICBcIlcwNFwiLFxuICAgIFwiVW5hYmxlIHRvIHByZXZlbnREZWZhdWx0IG9uIG5vbi1jYW5jZWxhYmxlIGV2ZW50cy5cIixcbilcblxuZXhwb3J0IGNvbnN0IENhbmNlbGVkSW5QYXNzaXZlTGlzdGVuZXIgPSBuZXcgV2FybmluZzxbXT4oXG4gICAgXCJXMDVcIixcbiAgICBcIlVuYWJsZSB0byBwcmV2ZW50RGVmYXVsdCBpbnNpZGUgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBpbnZvY2F0aW9uLlwiLFxuKVxuXG5leHBvcnQgY29uc3QgRXZlbnRMaXN0ZW5lcldhc0R1cGxpY2F0ZWQgPSBuZXcgV2FybmluZzxcbiAgICBbdHlwZTogXCJidWJibGVcIiB8IFwiY2FwdHVyZVwiLCBjYWxsYmFjazogRXZlbnRUYXJnZXQuRXZlbnRMaXN0ZW5lcjxhbnksIGFueT5dXG4+KFxuICAgIFwiVzA2XCIsXG4gICAgXCJBbiBldmVudCBsaXN0ZW5lciB3YXNuJ3QgYWRkZWQgYmVjYXVzZSBpdCBoYXMgYmVlbiBhZGRlZCBhbHJlYWR5OiAlbywgJW9cIixcbilcblxuZXhwb3J0IGNvbnN0IE9wdGlvbldhc0lnbm9yZWQgPSBuZXcgV2FybmluZzxcbiAgICBbbmFtZTogXCJwYXNzaXZlXCIgfCBcIm9uY2VcIiB8IFwic2lnbmFsXCJdXG4+KFxuICAgIFwiVzA3XCIsXG4gICAgXCJUaGUgJW8gb3B0aW9uIHZhbHVlIHdhcyBhYmFuZG9uZWQgYmVjYXVzZSB0aGUgZXZlbnQgbGlzdGVuZXIgd2Fzbid0IGFkZGVkIGFzIGR1cGxpY2F0ZWQuXCIsXG4pXG5cbmV4cG9ydCBjb25zdCBJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IG5ldyBXYXJuaW5nPFxuICAgIFtjYWxsYmFjazogRXZlbnRUYXJnZXQuRXZlbnRMaXN0ZW5lcjxhbnksIGFueT4gfCB7fSB8IG51bGwgfCB1bmRlZmluZWRdXG4+KFxuICAgIFwiVzA4XCIsXG4gICAgXCJUaGUgJ2NhbGxiYWNrJyBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHRoYXQgaGFzICdoYW5kbGVFdmVudCcgbWV0aG9kOiAlb1wiLFxuKVxuXG5leHBvcnQgY29uc3QgSW52YWxpZEF0dHJpYnV0ZUhhbmRsZXIgPSBuZXcgV2FybmluZzxcbiAgICBbY2FsbGJhY2s6IEV2ZW50VGFyZ2V0LkV2ZW50TGlzdGVuZXI8YW55LCBhbnk+IHwge31dXG4+KFwiVzA5XCIsIFwiRXZlbnQgYXR0cmlidXRlIGhhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uOiAlb1wiKVxuIiwiaW1wb3J0IHsgRXZlbnRUYXJnZXQgfSBmcm9tIFwiLi9ldmVudC10YXJnZXRcIiAvLyBVc2VkIGFzIG9ubHkgdHlwZSwgc28gbm8gY2lyY3VsYXIuXG5pbXBvcnQgeyBHbG9iYWwgfSBmcm9tIFwiLi9nbG9iYWxcIlxuaW1wb3J0IHsgYXNzZXJ0VHlwZSB9IGZyb20gXCIuL21pc2NcIlxuaW1wb3J0IHtcbiAgICBDYW5jZWxlZEluUGFzc2l2ZUxpc3RlbmVyLFxuICAgIEZhbHN5V2FzQXNzaWduZWRUb0NhbmNlbEJ1YmJsZSxcbiAgICBJbml0RXZlbnRXYXNDYWxsZWRXaGlsZURpc3BhdGNoaW5nLFxuICAgIE5vbkNhbmNlbGFibGVFdmVudFdhc0NhbmNlbGVkLFxuICAgIFRydXRoeVdhc0Fzc2lnbmVkVG9SZXR1cm5WYWx1ZSxcbn0gZnJvbSBcIi4vd2FybmluZ3NcIlxuXG4vKmVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgRXZlbnRgIGludGVyZmFjZSwgdGhhdCB3cmFwcyBhIGdpdmVuIGV2ZW50IG9iamVjdC5cbiAqIGBFdmVudFRhcmdldGAgc2hpbSBjYW4gY29udHJvbCB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhpcyBgRXZlbnRgIG9iamVjdHMuXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZXZlbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50PFRFdmVudFR5cGUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LW5vbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE5PTkUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE5PTkVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWNhcHR1cmluZ19waGFzZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgQ0FQVFVSSU5HX1BIQVNFKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBDQVBUVVJJTkdfUEhBU0VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWF0X3RhcmdldFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgQVRfVEFSR0VUKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBBVF9UQVJHRVRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWJ1YmJsaW5nX3BoYXNlXG4gICAgICovXG4gICAgc3RhdGljIGdldCBCVUJCTElOR19QSEFTRSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gQlVCQkxJTkdfUEhBU0VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoaXMgZXZlbnQgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnRJbml0RGljdCBPcHRpb25zIHRvIGluaXRpYWxpemUuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1ldmVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGU6IFRFdmVudFR5cGUsIGV2ZW50SW5pdERpY3Q/OiBFdmVudC5FdmVudEluaXQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUcnVzdGVkXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3Qgb3B0cyA9IGV2ZW50SW5pdERpY3QgPz8ge31cbiAgICAgICAgaW50ZXJuYWxEYXRhTWFwLnNldCh0aGlzLCB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcodHlwZSksXG4gICAgICAgICAgICBidWJibGVzOiBCb29sZWFuKG9wdHMuYnViYmxlcyksXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiBCb29sZWFuKG9wdHMuY2FuY2VsYWJsZSksXG4gICAgICAgICAgICBjb21wb3NlZDogQm9vbGVhbihvcHRzLmNvbXBvc2VkKSxcbiAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IG51bGwsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb25GbGFnOiBmYWxzZSxcbiAgICAgICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbkZsYWc6IGZhbHNlLFxuICAgICAgICAgICAgY2FuY2VsZWRGbGFnOiBmYWxzZSxcbiAgICAgICAgICAgIGluUGFzc2l2ZUxpc3RlbmVyRmxhZzogZmFsc2UsXG4gICAgICAgICAgICBkaXNwYXRjaEZsYWc6IGZhbHNlLFxuICAgICAgICAgICAgdGltZVN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC10eXBlXG4gICAgICovXG4gICAgZ2V0IHR5cGUoKTogVEV2ZW50VHlwZSB7XG4gICAgICAgIHJldHVybiAkKHRoaXMpLnR5cGUgYXMgVEV2ZW50VHlwZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCB0YXJnZXQgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC10YXJnZXRcbiAgICAgKi9cbiAgICBnZXQgdGFyZ2V0KCk6IEV2ZW50VGFyZ2V0IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiAkKHRoaXMpLnRhcmdldFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCB0YXJnZXQgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgdGFyZ2V0YCBwcm9wZXJ0eSBpbnN0ZWFkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtc3JjZWxlbWVudFxuICAgICAqL1xuICAgIGdldCBzcmNFbGVtZW50KCk6IEV2ZW50VGFyZ2V0IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiAkKHRoaXMpLnRhcmdldFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCB0YXJnZXQgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1jdXJyZW50dGFyZ2V0XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRUYXJnZXQoKTogRXZlbnRUYXJnZXQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykuY3VycmVudFRhcmdldFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCB0YXJnZXQgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICogVGhpcyBkb2Vzbid0IHN1cHBvcnQgbm9kZSB0cmVlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY29tcG9zZWRwYXRoXG4gICAgICovXG4gICAgY29tcG9zZWRQYXRoKCk6IEV2ZW50VGFyZ2V0W10ge1xuICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gJCh0aGlzKS5jdXJyZW50VGFyZ2V0XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gW2N1cnJlbnRUYXJnZXRdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1ub25lXG4gICAgICovXG4gICAgZ2V0IE5PTkUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE5PTkVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWNhcHR1cmluZ19waGFzZVxuICAgICAqL1xuICAgIGdldCBDQVBUVVJJTkdfUEhBU0UoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIENBUFRVUklOR19QSEFTRVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtYXRfdGFyZ2V0XG4gICAgICovXG4gICAgZ2V0IEFUX1RBUkdFVCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gQVRfVEFSR0VUXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1idWJibGluZ19waGFzZVxuICAgICAqL1xuICAgIGdldCBCVUJCTElOR19QSEFTRSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gQlVCQkxJTkdfUEhBU0VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBldmVudCBwaGFzZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWV2ZW50cGhhc2VcbiAgICAgKi9cbiAgICBnZXQgZXZlbnRQaGFzZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5kaXNwYXRjaEZsYWcgPyAyIDogMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQmVjYXVzZSB0aGlzIHNoaW0gZG9lc24ndCBzdXBwb3J0IG5vZGUgdHJlZSwgdGhpcyBtZXJlbHkgY2hhbmdlcyB0aGUgYGNhbmNlbEJ1YmJsZWAgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1zdG9wcHJvcGFnYXRpb25cbiAgICAgKi9cbiAgICBzdG9wUHJvcGFnYXRpb24oKTogdm9pZCB7XG4gICAgICAgICQodGhpcykuc3RvcFByb3BhZ2F0aW9uRmxhZyA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgaWYgZXZlbnQgYnViYmxpbmcgd2FzIHN0b3BwZWQuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWNhbmNlbGJ1YmJsZVxuICAgICAqL1xuICAgIGdldCBjYW5jZWxCdWJibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAkKHRoaXMpLnN0b3BQcm9wYWdhdGlvbkZsYWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGV2ZW50IGJ1YmJsaW5nIGlmIGB0cnVlYCBpcyBzZXQuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgc3RvcFByb3BhZ2F0aW9uKClgIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY2FuY2VsYnViYmxlXG4gICAgICovXG4gICAgc2V0IGNhbmNlbEJ1YmJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICQodGhpcykuc3RvcFByb3BhZ2F0aW9uRmxhZyA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEZhbHN5V2FzQXNzaWduZWRUb0NhbmNlbEJ1YmJsZS53YXJuKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcgYW5kIHN1YnNlcXVlbnQgZXZlbnQgbGlzdGVuZXIgY2FsbGluZ3MuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1zdG9waW1tZWRpYXRlcHJvcGFnYXRpb25cbiAgICAgKi9cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAkKHRoaXMpXG4gICAgICAgIGRhdGEuc3RvcFByb3BhZ2F0aW9uRmxhZyA9IGRhdGEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uRmxhZyA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgaWYgdGhpcyBldmVudCB3aWxsIGJ1YmJsZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWJ1YmJsZXNcbiAgICAgKi9cbiAgICBnZXQgYnViYmxlcygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykuYnViYmxlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGB0cnVlYCBpZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxlZCBieSB0aGUgYHByZXZlbnREZWZhdWx0KClgIG1ldGhvZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWNhbmNlbGFibGVcbiAgICAgKi9cbiAgICBnZXQgY2FuY2VsYWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykuY2FuY2VsYWJsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGB0cnVlYCBpZiB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGFjdC5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBkZWZhdWx0UHJldmVudGVkYCBwcm9lcHJ0eSBpbnN0ZWFkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtcmV0dXJudmFsdWVcbiAgICAgKi9cbiAgICBnZXQgcmV0dXJuVmFsdWUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhJCh0aGlzKS5jYW5jZWxlZEZsYWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaWYgYGZhbHNlYCBpcyBzZXQuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgcHJldmVudERlZmF1bHQoKWAgbWV0aG9kIGluc3RlYWQuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1yZXR1cm52YWx1ZVxuICAgICAqL1xuICAgIHNldCByZXR1cm5WYWx1ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBzZXRDYW5jZWxGbGFnKCQodGhpcykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcnV0aHlXYXNBc3NpZ25lZFRvUmV0dXJuVmFsdWUud2FybigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1wcmV2ZW50ZGVmYXVsdFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCk6IHZvaWQge1xuICAgICAgICBzZXRDYW5jZWxGbGFnKCQodGhpcykpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYHRydWVgIGlmIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdhcyBjYW5jZWxlZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWRlZmF1bHRwcmV2ZW50ZWRcbiAgICAgKi9cbiAgICBnZXQgZGVmYXVsdFByZXZlbnRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykuY2FuY2VsZWRGbGFnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1jb21wb3NlZFxuICAgICAqL1xuICAgIGdldCBjb21wb3NlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykuY29tcG9zZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWlzdHJ1c3RlZFxuICAgICAqL1xuICAgIC8vaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBnZXQgaXNUcnVzdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXRpbWVzdGFtcFxuICAgICAqL1xuICAgIGdldCB0aW1lU3RhbXAoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykudGltZVN0YW1wXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRG9uJ3QgdXNlIHRoaXMgbWV0aG9kLiBUaGUgY29uc3RydWN0b3IgZGlkIGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIGluaXRFdmVudCh0eXBlOiBzdHJpbmcsIGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAkKHRoaXMpXG4gICAgICAgIGlmIChkYXRhLmRpc3BhdGNoRmxhZykge1xuICAgICAgICAgICAgSW5pdEV2ZW50V2FzQ2FsbGVkV2hpbGVEaXNwYXRjaGluZy53YXJuKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJuYWxEYXRhTWFwLnNldCh0aGlzLCB7XG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgdHlwZTogU3RyaW5nKHR5cGUpLFxuICAgICAgICAgICAgYnViYmxlczogQm9vbGVhbihidWJibGVzKSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IEJvb2xlYW4oY2FuY2VsYWJsZSksXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uRmxhZzogZmFsc2UsXG4gICAgICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25GbGFnOiBmYWxzZSxcbiAgICAgICAgICAgIGNhbmNlbGVkRmxhZzogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG4vKmVzbGludC1lbmFibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuXG5leHBvcnQgbmFtZXNwYWNlIEV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyBvZiB0aGUgYEV2ZW50YCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZGljdGRlZi1ldmVudGluaXRcbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIEV2ZW50SW5pdCB7XG4gICAgICAgIGJ1YmJsZXM/OiBib29sZWFuXG4gICAgICAgIGNhbmNlbGFibGU/OiBib29sZWFuXG4gICAgICAgIGNvbXBvc2VkPzogYm9vbGVhblxuICAgIH1cbn1cblxuZXhwb3J0IHsgJCBhcyBnZXRFdmVudEludGVybmFsRGF0YSB9XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBOT05FID0gMFxuY29uc3QgQ0FQVFVSSU5HX1BIQVNFID0gMVxuY29uc3QgQVRfVEFSR0VUID0gMlxuY29uc3QgQlVCQkxJTkdfUEhBU0UgPSAzXG5cbi8qKlxuICogUHJpdmF0ZSBkYXRhLlxuICovXG5pbnRlcmZhY2UgRXZlbnRJbnRlcm5hbERhdGEge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiBgdHlwZWAgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHR5cGU6IHN0cmluZ1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiBgYnViYmxlc2AgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGJ1YmJsZXM6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgYGNhbmNlbGFibGVgIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICByZWFkb25seSBjYW5jZWxhYmxlOiBib29sZWFuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIGBjb21wb3NlZGAgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbXBvc2VkOiBib29sZWFuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIGB0aW1lU3RhbXBgIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICByZWFkb25seSB0aW1lU3RhbXA6IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC10YXJnZXRcbiAgICAgKi9cbiAgICB0YXJnZXQ6IEV2ZW50VGFyZ2V0IHwgbnVsbFxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY3VycmVudHRhcmdldFxuICAgICAqL1xuICAgIGN1cnJlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0IHwgbnVsbFxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNzdG9wLXByb3BhZ2F0aW9uLWZsYWdcbiAgICAgKi9cbiAgICBzdG9wUHJvcGFnYXRpb25GbGFnOiBib29sZWFuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI3N0b3AtaW1tZWRpYXRlLXByb3BhZ2F0aW9uLWZsYWdcbiAgICAgKi9cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25GbGFnOiBib29sZWFuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NhbmNlbGVkLWZsYWdcbiAgICAgKi9cbiAgICBjYW5jZWxlZEZsYWc6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jaW4tcGFzc2l2ZS1saXN0ZW5lci1mbGFnXG4gICAgICovXG4gICAgaW5QYXNzaXZlTGlzdGVuZXJGbGFnOiBib29sZWFuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2Rpc3BhdGNoLWZsYWdcbiAgICAgKi9cbiAgICBkaXNwYXRjaEZsYWc6IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBQcml2YXRlIGRhdGEgZm9yIGV2ZW50IHdyYXBwZXJzLlxuICovXG5jb25zdCBpbnRlcm5hbERhdGFNYXAgPSBuZXcgV2Vha01hcDxhbnksIEV2ZW50SW50ZXJuYWxEYXRhPigpXG5cbi8qKlxuICogR2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IHRvIGdldCBwcml2YXRlIGRhdGEuXG4gKiBAcGFyYW0gbmFtZSBUaGUgdmFyaWFibGUgbmFtZSB0byByZXBvcnQuXG4gKiBAcmV0dXJucyBUaGUgcHJpdmF0ZSBkYXRhIG9mIHRoZSBldmVudC5cbiAqL1xuZnVuY3Rpb24gJChldmVudDogdW5rbm93biwgbmFtZSA9IFwidGhpc1wiKTogRXZlbnRJbnRlcm5hbERhdGEge1xuICAgIGNvbnN0IHJldHYgPSBpbnRlcm5hbERhdGFNYXAuZ2V0KGV2ZW50KVxuICAgIGFzc2VydFR5cGUoXG4gICAgICAgIHJldHYgIT0gbnVsbCxcbiAgICAgICAgXCInJXMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgRXZlbnQgY29uc3RydWN0b3IgY3JlYXRlZCwgYnV0IGdvdCBhbm90aGVyIG9uZTogJW9cIixcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZXZlbnQsXG4gICAgKVxuICAgIHJldHVybiByZXR2XG59XG5cbi8qKlxuICogaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNzZXQtdGhlLWNhbmNlbGVkLWZsYWdcbiAqIEBwYXJhbSBkYXRhIHByaXZhdGUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FuY2VsRmxhZyhkYXRhOiBFdmVudEludGVybmFsRGF0YSkge1xuICAgIGlmIChkYXRhLmluUGFzc2l2ZUxpc3RlbmVyRmxhZykge1xuICAgICAgICBDYW5jZWxlZEluUGFzc2l2ZUxpc3RlbmVyLndhcm4oKVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFkYXRhLmNhbmNlbGFibGUpIHtcbiAgICAgICAgTm9uQ2FuY2VsYWJsZUV2ZW50V2FzQ2FuY2VsZWQud2FybigpXG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRhdGEuY2FuY2VsZWRGbGFnID0gdHJ1ZVxufVxuXG4vLyBTZXQgZW51bWVyYWJsZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LCBcIk5PTkVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQsIFwiQ0FQVFVSSU5HX1BIQVNFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LCBcIkFUX1RBUkdFVFwiLCB7IGVudW1lcmFibGU6IHRydWUgfSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudCwgXCJCVUJCTElOR19QSEFTRVwiLCB7IGVudW1lcmFibGU6IHRydWUgfSlcbmNvbnN0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhFdmVudC5wcm90b3R5cGUpXG5mb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoa2V5c1tpXSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIGtleXNbaV0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KVxufVxuXG4vLyBFbnN1cmUgYGV2ZW50IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50YCBpcyBgdHJ1ZWAuXG5pZiAodHlwZW9mIEdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgR2xvYmFsLkV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50LnByb3RvdHlwZSwgR2xvYmFsLkV2ZW50LnByb3RvdHlwZSlcbn1cbiIsImltcG9ydCB7IEdsb2JhbCB9IGZyb20gXCIuL2dsb2JhbFwiXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEludmFsaWRTdGF0ZUVycm9yIGluc3RhbmNlLlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcihtZXNzYWdlOiBzdHJpbmcpOiBFcnJvciB7XG4gICAgaWYgKEdsb2JhbC5ET01FeGNlcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWwuRE9NRXhjZXB0aW9uKG1lc3NhZ2UsIFwiSW52YWxpZFN0YXRlRXJyb3JcIilcbiAgICB9XG5cbiAgICBpZiAoRE9NRXhjZXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgRE9NRXhjZXB0aW9uID0gY2xhc3MgRE9NRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICAgICAgY29uc3RydWN0b3IobXNnOiBzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBzdXBlcihtc2cpXG4gICAgICAgICAgICAgICAgaWYgKChFcnJvciBhcyBhbnkpLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIDsoRXJyb3IgYXMgYW55KS5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBET01FeGNlcHRpb24pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICAgICAgICAgIGdldCBjb2RlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICAgICAgICAgIGdldCBuYW1lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkludmFsaWRTdGF0ZUVycm9yXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhET01FeGNlcHRpb24ucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBjb2RlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIG5hbWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICB9KVxuICAgICAgICBkZWZpbmVFcnJvckNvZGVQcm9wZXJ0aWVzKERPTUV4Y2VwdGlvbilcbiAgICAgICAgZGVmaW5lRXJyb3JDb2RlUHJvcGVydGllcyhET01FeGNlcHRpb24ucHJvdG90eXBlKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERPTUV4Y2VwdGlvbihtZXNzYWdlKVxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubGV0IERPTUV4Y2VwdGlvbjogeyBuZXcgKG1lc3NhZ2U6IHN0cmluZyk6IEVycm9yIH0gfCB1bmRlZmluZWRcblxuY29uc3QgRXJyb3JDb2RlTWFwID0ge1xuICAgIElOREVYX1NJWkVfRVJSOiAxLFxuICAgIERPTVNUUklOR19TSVpFX0VSUjogMixcbiAgICBISUVSQVJDSFlfUkVRVUVTVF9FUlI6IDMsXG4gICAgV1JPTkdfRE9DVU1FTlRfRVJSOiA0LFxuICAgIElOVkFMSURfQ0hBUkFDVEVSX0VSUjogNSxcbiAgICBOT19EQVRBX0FMTE9XRURfRVJSOiA2LFxuICAgIE5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUjogNyxcbiAgICBOT1RfRk9VTkRfRVJSOiA4LFxuICAgIE5PVF9TVVBQT1JURURfRVJSOiA5LFxuICAgIElOVVNFX0FUVFJJQlVURV9FUlI6IDEwLFxuICAgIElOVkFMSURfU1RBVEVfRVJSOiAxMSxcbiAgICBTWU5UQVhfRVJSOiAxMixcbiAgICBJTlZBTElEX01PRElGSUNBVElPTl9FUlI6IDEzLFxuICAgIE5BTUVTUEFDRV9FUlI6IDE0LFxuICAgIElOVkFMSURfQUNDRVNTX0VSUjogMTUsXG4gICAgVkFMSURBVElPTl9FUlI6IDE2LFxuICAgIFRZUEVfTUlTTUFUQ0hfRVJSOiAxNyxcbiAgICBTRUNVUklUWV9FUlI6IDE4LFxuICAgIE5FVFdPUktfRVJSOiAxOSxcbiAgICBBQk9SVF9FUlI6IDIwLFxuICAgIFVSTF9NSVNNQVRDSF9FUlI6IDIxLFxuICAgIFFVT1RBX0VYQ0VFREVEX0VSUjogMjIsXG4gICAgVElNRU9VVF9FUlI6IDIzLFxuICAgIElOVkFMSURfTk9ERV9UWVBFX0VSUjogMjQsXG4gICAgREFUQV9DTE9ORV9FUlI6IDI1LFxufVxudHlwZSBFcnJvckNvZGVNYXAgPSB0eXBlb2YgRXJyb3JDb2RlTWFwXG5cbmZ1bmN0aW9uIGRlZmluZUVycm9yQ29kZVByb3BlcnRpZXMob2JqOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoRXJyb3JDb2RlTWFwKSBhcyAoa2V5b2YgRXJyb3JDb2RlTWFwKVtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBFcnJvckNvZGVNYXBba2V5XVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9KVxuICAgIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50IH0gZnJvbSBcIi4vZXZlbnRcIlxuaW1wb3J0IHsgR2xvYmFsIH0gZnJvbSBcIi4vZ2xvYmFsXCJcbmltcG9ydCB7IGFzc2VydFR5cGUgfSBmcm9tIFwiLi9taXNjXCJcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgRXZlbnRgIGludGVyZmFjZSwgdGhhdCB3cmFwcyBhIGdpdmVuIGV2ZW50IG9iamVjdC5cbiAqIFRoaXMgY2xhc3MgY29udHJvbHMgdGhlIGludGVybmFsIHN0YXRlIG9mIGBFdmVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWV2ZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudFdyYXBwZXI8VEV2ZW50VHlwZSBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBFdmVudDxURXZlbnRUeXBlPiB7XG4gICAgLyoqXG4gICAgICogV3JhcCBhIGdpdmVuIGV2ZW50IG9iamVjdCB0byBjb250cm9sIHN0YXRlcy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50LWxpa2Ugb2JqZWN0IHRvIHdyYXAuXG4gICAgICovXG4gICAgc3RhdGljIHdyYXA8VCBleHRlbmRzIEV2ZW50TGlrZT4oZXZlbnQ6IFQpOiBFdmVudFdyYXBwZXJPZjxUPiB7XG4gICAgICAgIHJldHVybiBuZXcgKGdldFdyYXBwZXJDbGFzc09mKGV2ZW50KSkoZXZlbnQpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGV2ZW50OiBFdmVudDxURXZlbnRUeXBlPikge1xuICAgICAgICBzdXBlcihldmVudC50eXBlLCB7XG4gICAgICAgICAgICBidWJibGVzOiBldmVudC5idWJibGVzLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiBldmVudC5jb21wb3NlZCxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZXZlbnQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICBzdXBlci5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICBzdXBlci5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIH1cblxuICAgICAgICBpbnRlcm5hbERhdGFNYXAuc2V0KHRoaXMsIHsgb3JpZ2luYWw6IGV2ZW50IH0pXG5cbiAgICAgICAgLy8gRGVmaW5lIGFjY2Vzc29yc1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnQpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihldmVudCwga2V5KSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wUHJvcGFnYXRpb24oKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICAgICAgY29uc3QgeyBvcmlnaW5hbCB9ID0gJCh0aGlzKVxuICAgICAgICBpZiAoXCJzdG9wUHJvcGFnYXRpb25cIiBpbiBvcmlnaW5hbCkge1xuICAgICAgICAgICAgb3JpZ2luYWwuc3RvcFByb3BhZ2F0aW9uISgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY2FuY2VsQnViYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3VwZXIuY2FuY2VsQnViYmxlXG4gICAgfVxuICAgIHNldCBjYW5jZWxCdWJibGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgc3VwZXIuY2FuY2VsQnViYmxlID0gdmFsdWVcblxuICAgICAgICBjb25zdCB7IG9yaWdpbmFsIH0gPSAkKHRoaXMpXG4gICAgICAgIGlmIChcImNhbmNlbEJ1YmJsZVwiIGluIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBvcmlnaW5hbC5jYW5jZWxCdWJibGUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk6IHZvaWQge1xuICAgICAgICBzdXBlci5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuXG4gICAgICAgIGNvbnN0IHsgb3JpZ2luYWwgfSA9ICQodGhpcylcbiAgICAgICAgaWYgKFwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCIgaW4gb3JpZ2luYWwpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiEoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHJldHVyblZhbHVlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3VwZXIucmV0dXJuVmFsdWVcbiAgICB9XG4gICAgc2V0IHJldHVyblZhbHVlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHN1cGVyLnJldHVyblZhbHVlID0gdmFsdWVcblxuICAgICAgICBjb25zdCB7IG9yaWdpbmFsIH0gPSAkKHRoaXMpXG4gICAgICAgIGlmIChcInJldHVyblZhbHVlXCIgaW4gb3JpZ2luYWwpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsLnJldHVyblZhbHVlID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByZXZlbnREZWZhdWx0KCk6IHZvaWQge1xuICAgICAgICBzdXBlci5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgICAgY29uc3QgeyBvcmlnaW5hbCB9ID0gJCh0aGlzKVxuICAgICAgICBpZiAoXCJwcmV2ZW50RGVmYXVsdFwiIGluIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBvcmlnaW5hbC5wcmV2ZW50RGVmYXVsdCEoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRpbWVTdGFtcCgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCB7IG9yaWdpbmFsIH0gPSAkKHRoaXMpXG4gICAgICAgIGlmIChcInRpbWVTdGFtcFwiIGluIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwudGltZVN0YW1wIVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci50aW1lU3RhbXBcbiAgICB9XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG50eXBlIEV2ZW50TGlrZSA9IHsgcmVhZG9ubHkgdHlwZTogc3RyaW5nIH0gJiBQYXJ0aWFsPEV2ZW50PlxudHlwZSBFdmVudFdyYXBwZXJPZjxUIGV4dGVuZHMgRXZlbnRMaWtlPiA9IEV2ZW50PFRbXCJ0eXBlXCJdPiAmXG4gICAgT21pdDxULCBrZXlvZiBFdmVudD5cblxuaW50ZXJmYWNlIEV2ZW50V3JhcHBlckludGVybmFsRGF0YSB7XG4gICAgcmVhZG9ubHkgb3JpZ2luYWw6IEV2ZW50TGlrZVxufVxuXG4vKipcbiAqIFByaXZhdGUgZGF0YSBmb3IgZXZlbnQgd3JhcHBlcnMuXG4gKi9cbmNvbnN0IGludGVybmFsRGF0YU1hcCA9IG5ldyBXZWFrTWFwPGFueSwgRXZlbnRXcmFwcGVySW50ZXJuYWxEYXRhPigpXG5cbi8qKlxuICogR2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IHRvIGdldCBwcml2YXRlIGRhdGEuXG4gKiBAcmV0dXJucyBUaGUgcHJpdmF0ZSBkYXRhIG9mIHRoZSBldmVudC5cbiAqL1xuZnVuY3Rpb24gJChldmVudDogdW5rbm93bik6IEV2ZW50V3JhcHBlckludGVybmFsRGF0YSB7XG4gICAgY29uc3QgcmV0diA9IGludGVybmFsRGF0YU1hcC5nZXQoZXZlbnQpXG4gICAgYXNzZXJ0VHlwZShcbiAgICAgICAgcmV0diAhPSBudWxsLFxuICAgICAgICBcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudCBvYmplY3QsIGJ1dCBnb3RcIixcbiAgICAgICAgZXZlbnQsXG4gICAgKVxuICAgIHJldHVybiByZXR2XG59XG5cbi8qKlxuICogQ2FjaGUgZm9yIHdyYXBwZXIgY2xhc3Nlcy5cbiAqIEB0eXBlIHtXZWFrTWFwPE9iamVjdCwgRnVuY3Rpb24+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgd3JhcHBlckNsYXNzQ2FjaGUgPSBuZXcgV2Vha01hcCgpXG5cbi8vIE1ha2UgYXNzb2NpYXRpb24gZm9yIHdyYXBwZXJzLlxud3JhcHBlckNsYXNzQ2FjaGUuc2V0KE9iamVjdC5wcm90b3R5cGUsIEV2ZW50V3JhcHBlcilcbmlmICh0eXBlb2YgR2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBHbG9iYWwuRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3cmFwcGVyQ2xhc3NDYWNoZS5zZXQoR2xvYmFsLkV2ZW50LnByb3RvdHlwZSwgRXZlbnRXcmFwcGVyKVxufVxuXG4vKipcbiAqIEdldCB0aGUgd3JhcHBlciBjbGFzcyBvZiBhIGdpdmVuIHByb3RvdHlwZS5cbiAqIEBwYXJhbSBvcmlnaW5hbEV2ZW50IFRoZSBldmVudCBvYmplY3QgdG8gd3JhcC5cbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcHBlckNsYXNzT2Y8VCBleHRlbmRzIEV2ZW50TGlrZT4oXG4gICAgb3JpZ2luYWxFdmVudDogVCxcbik6IHsgbmV3IChlOiBUKTogRXZlbnRXcmFwcGVyT2Y8VD4gfSB7XG4gICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsRXZlbnQpXG4gICAgaWYgKHByb3RvdHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBFdmVudFdyYXBwZXIgYXMgYW55XG4gICAgfVxuXG4gICAgbGV0IHdyYXBwZXI6IGFueSA9IHdyYXBwZXJDbGFzc0NhY2hlLmdldChwcm90b3R5cGUpXG4gICAgaWYgKHdyYXBwZXIgPT0gbnVsbCkge1xuICAgICAgICB3cmFwcGVyID0gZGVmaW5lV3JhcHBlcihnZXRXcmFwcGVyQ2xhc3NPZihwcm90b3R5cGUpLCBwcm90b3R5cGUpXG4gICAgICAgIHdyYXBwZXJDbGFzc0NhY2hlLnNldChwcm90b3R5cGUsIHdyYXBwZXIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBwZXJcbn1cblxuLyoqXG4gKiBEZWZpbmUgbmV3IHdyYXBwZXIgY2xhc3MuXG4gKiBAcGFyYW0gQmFzZUV2ZW50V3JhcHBlciBUaGUgYmFzZSB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIG9yaWdpbmFsUHJvdG90eXBlIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50LlxuICovXG5mdW5jdGlvbiBkZWZpbmVXcmFwcGVyKEJhc2VFdmVudFdyYXBwZXI6IGFueSwgb3JpZ2luYWxQcm90b3R5cGU6IGFueSk6IGFueSB7XG4gICAgY2xhc3MgQ3VzdG9tRXZlbnRXcmFwcGVyIGV4dGVuZHMgQmFzZUV2ZW50V3JhcHBlciB7fVxuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9yaWdpbmFsUHJvdG90eXBlKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICBDdXN0b21FdmVudFdyYXBwZXIucHJvdG90eXBlLFxuICAgICAgICAgICAga2V5c1tpXSxcbiAgICAgICAgICAgIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihvcmlnaW5hbFByb3RvdHlwZSwga2V5c1tpXSksXG4gICAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gQ3VzdG9tRXZlbnRXcmFwcGVyXG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IGEgZ2l2ZW4gcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihvYmo6IGFueSwga2V5OiBzdHJpbmcpOiBQcm9wZXJ0eURlc2NyaXB0b3Ige1xuICAgIGNvbnN0IGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSFcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbDogYW55ID0gJCh0aGlzKS5vcmlnaW5hbFxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvcmlnaW5hbFtrZXldXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYmluZChvcmlnaW5hbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWU6IGFueSkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWw6IGFueSA9ICQodGhpcykub3JpZ2luYWxcbiAgICAgICAgICAgIG9yaWdpbmFsW2tleV0gPSB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IGQuY29uZmlndXJhYmxlLFxuICAgICAgICBlbnVtZXJhYmxlOiBkLmVudW1lcmFibGUsXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgcmVwb3J0RXJyb3IgfSBmcm9tIFwiLi9lcnJvci1oYW5kbGVyXCJcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSBcIi4vZXZlbnRcIiAvLyBVc2VkIGFzIG9ubHkgdHlwZSwgc28gbm8gY2lyY3VsYXIuXG5pbXBvcnQgeyBFdmVudFRhcmdldCB9IGZyb20gXCIuL2V2ZW50LXRhcmdldFwiIC8vIFVzZWQgYXMgb25seSB0eXBlLCBzbyBubyBjaXJjdWxhci5cblxuLyoqXG4gKiBUaGUgZXZlbnQgbGlzdGVuZXIgY29uY2VwdC5cbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWV2ZW50LWxpc3RlbmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGVuZXIge1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICByZWFkb25seSBjYWxsYmFjazogTGlzdGVuZXIuQ2FsbGJhY2s8YW55LCBhbnk+XG4gICAgLyoqXG4gICAgICogVGhlIGZsYWdzIG9mIHRoaXMgbGlzdGVuZXIuXG4gICAgICogVGhpcyBpcyB3cml0YWJsZSB0byBhZGQgdGhlIHJlbW92ZWQgZmxhZy5cbiAgICAgKi9cbiAgICBmbGFnczogTGlzdGVuZXJGbGFnc1xuICAgIC8qKlxuICAgICAqIFRoZSBgQWJvcnRTaWduYWxgIHRvIHJlbW92ZSB0aGlzIGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNpZ25hbDogTGlzdGVuZXIuQWJvcnRTaWduYWwgfCB1bmRlZmluZWRcbiAgICAvKipcbiAgICAgKiBUaGUgYGFib3J0YCBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGBzaWduYWxgLlxuICAgICAqIFRvIHJlbW92ZSBpdCBmcm9tIHRoZSBgc2lnbmFsYC5cbiAgICAgKi9cbiAgICByZWFkb25seSBzaWduYWxMaXN0ZW5lcjogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgTGlzdGVuZXIge1xuICAgIGV4cG9ydCB0eXBlIENhbGxiYWNrPFxuICAgICAgICBURXZlbnRUYXJnZXQgZXh0ZW5kcyBFdmVudFRhcmdldDxhbnksIGFueT4sXG4gICAgICAgIFRFdmVudCBleHRlbmRzIEV2ZW50XG4gICAgPiA9IENhbGxiYWNrRnVuY3Rpb248VEV2ZW50VGFyZ2V0LCBURXZlbnQ+IHwgQ2FsbGJhY2tPYmplY3Q8VEV2ZW50PlxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBDYWxsYmFja0Z1bmN0aW9uPFxuICAgICAgICBURXZlbnRUYXJnZXQgZXh0ZW5kcyBFdmVudFRhcmdldDxhbnksIGFueT4sXG4gICAgICAgIFRFdmVudCBleHRlbmRzIEV2ZW50XG4gICAgPiB7XG4gICAgICAgICh0aGlzOiBURXZlbnRUYXJnZXQsIGV2ZW50OiBURXZlbnQpOiB2b2lkXG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBDYWxsYmFja09iamVjdDxURXZlbnQgZXh0ZW5kcyBFdmVudD4ge1xuICAgICAgICBoYW5kbGVFdmVudChldmVudDogVEV2ZW50KTogdm9pZFxuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgQWJvcnRTaWduYWwge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKHR5cGU6IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrPGFueSwgRXZlbnQ+KTogdm9pZFxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGU6IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrPGFueSwgRXZlbnQ+KTogdm9pZFxuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbGlzdGVuZXIuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIGNhcHR1cmUgVGhlIGNhcHR1cmUgZmxhZy5cbiAqIEBwYXJhbSBwYXNzaXZlIFRoZSBwYXNzaXZlIGZsYWcuXG4gKiBAcGFyYW0gb25jZSBUaGUgb25jZSBmbGFnLlxuICogQHBhcmFtIHNpZ25hbCBUaGUgYWJvcnQgc2lnbmFsLlxuICogQHBhcmFtIHNpZ25hbExpc3RlbmVyIFRoZSBhYm9ydCBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGFib3J0IHNpZ25hbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyKFxuICAgIGNhbGxiYWNrOiBMaXN0ZW5lci5DYWxsYmFjazxhbnksIGFueT4sXG4gICAgY2FwdHVyZTogYm9vbGVhbixcbiAgICBwYXNzaXZlOiBib29sZWFuLFxuICAgIG9uY2U6IGJvb2xlYW4sXG4gICAgc2lnbmFsOiBMaXN0ZW5lci5BYm9ydFNpZ25hbCB8IHVuZGVmaW5lZCxcbiAgICBzaWduYWxMaXN0ZW5lcjogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkLFxuKTogTGlzdGVuZXIge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBmbGFnczpcbiAgICAgICAgICAgIChjYXB0dXJlID8gTGlzdGVuZXJGbGFncy5DYXB0dXJlIDogMCkgfFxuICAgICAgICAgICAgKHBhc3NpdmUgPyBMaXN0ZW5lckZsYWdzLlBhc3NpdmUgOiAwKSB8XG4gICAgICAgICAgICAob25jZSA/IExpc3RlbmVyRmxhZ3MuT25jZSA6IDApLFxuICAgICAgICBzaWduYWwsXG4gICAgICAgIHNpZ25hbExpc3RlbmVyLFxuICAgIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIGByZW1vdmVkYCBmbGFnIHRvIHRoZSBnaXZlbiBsaXN0ZW5lci5cbiAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZW1vdmVkKGxpc3RlbmVyOiBMaXN0ZW5lcik6IHZvaWQge1xuICAgIGxpc3RlbmVyLmZsYWdzIHw9IExpc3RlbmVyRmxhZ3MuUmVtb3ZlZFxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBsaXN0ZW5lciBoYXMgdGhlIGBjYXB0dXJlYCBmbGFnIG9yIG5vdC5cbiAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhcHR1cmUobGlzdGVuZXI6IExpc3RlbmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChsaXN0ZW5lci5mbGFncyAmIExpc3RlbmVyRmxhZ3MuQ2FwdHVyZSkgPT09IExpc3RlbmVyRmxhZ3MuQ2FwdHVyZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBsaXN0ZW5lciBoYXMgdGhlIGBwYXNzaXZlYCBmbGFnIG9yIG5vdC5cbiAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Bhc3NpdmUobGlzdGVuZXI6IExpc3RlbmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChsaXN0ZW5lci5mbGFncyAmIExpc3RlbmVyRmxhZ3MuUGFzc2l2ZSkgPT09IExpc3RlbmVyRmxhZ3MuUGFzc2l2ZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBsaXN0ZW5lciBoYXMgdGhlIGBvbmNlYCBmbGFnIG9yIG5vdC5cbiAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09uY2UobGlzdGVuZXI6IExpc3RlbmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChsaXN0ZW5lci5mbGFncyAmIExpc3RlbmVyRmxhZ3MuT25jZSkgPT09IExpc3RlbmVyRmxhZ3MuT25jZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBsaXN0ZW5lciBoYXMgdGhlIGByZW1vdmVkYCBmbGFnIG9yIG5vdC5cbiAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JlbW92ZWQobGlzdGVuZXI6IExpc3RlbmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChsaXN0ZW5lci5mbGFncyAmIExpc3RlbmVyRmxhZ3MuUmVtb3ZlZCkgPT09IExpc3RlbmVyRmxhZ3MuUmVtb3ZlZFxufVxuXG4vKipcbiAqIENhbGwgYW4gZXZlbnQgbGlzdGVuZXIuXG4gKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGNhbGwuXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2JqZWN0IGZvciBgdGhpc0FyZ2AuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCBmb3IgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICogQHBhcmFtIGF0dHJpYnV0ZSBgdHJ1ZWAgaWYgdGhpcyBjYWxsYmFjayBpcyBhbiBldmVudCBhdHRyaWJ1dGUgaGFuZGxlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKFxuICAgIHsgY2FsbGJhY2sgfTogTGlzdGVuZXIsXG4gICAgdGFyZ2V0OiBFdmVudFRhcmdldDxhbnksIGFueT4sXG4gICAgZXZlbnQ6IEV2ZW50PGFueT4sXG4pOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGFyZ2V0LCBldmVudClcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2suaGFuZGxlRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2suaGFuZGxlRXZlbnQoZXZlbnQpXG4gICAgICAgIH1cbiAgICB9IGNhdGNoICh0aHJvd25FcnJvcikge1xuICAgICAgICByZXBvcnRFcnJvcih0aHJvd25FcnJvcilcbiAgICB9XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRoZSBmbGFncyBvZiBsaXN0ZW5lcnMuXG4gKi9cbmNvbnN0IGVudW0gTGlzdGVuZXJGbGFncyB7XG4gICAgQ2FwdHVyZSA9IDB4MDEsXG4gICAgUGFzc2l2ZSA9IDB4MDIsXG4gICAgT25jZSA9IDB4MDQsXG4gICAgUmVtb3ZlZCA9IDB4MDgsXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVMaXN0ZW5lciwgaXNDYXB0dXJlLCBMaXN0ZW5lciwgc2V0UmVtb3ZlZCB9IGZyb20gXCIuL2xpc3RlbmVyXCJcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBvZiBhbiBsaXN0ZW5lciBsaXN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExpc3RlbmVyTGlzdCB7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIG9mIHRoZSBldmVudCBhdHRyaWJ1dGUgaGFuZGxlci5cbiAgICAgKi9cbiAgICBhdHRyQ2FsbGJhY2s6IExpc3RlbmVyLkNhbGxiYWNrRnVuY3Rpb248YW55LCBhbnk+IHwgdW5kZWZpbmVkXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3RlbmVyIG9mIHRoZSBldmVudCBhdHRyaWJ1dGUgaGFuZGxlci5cbiAgICAgKi9cbiAgICBhdHRyTGlzdGVuZXI6IExpc3RlbmVyIHwgdW5kZWZpbmVkXG4gICAgLyoqXG4gICAgICogYHRydWVgIGlmIHRoZSBgZGlzcGF0Y2hFdmVudGAgbWV0aG9kIGlzIHRyYXZlcnNpbmcgdGhlIGN1cnJlbnQgYGxpc3RlbmVyc2AgYXJyYXkuXG4gICAgICovXG4gICAgY293OiBib29sZWFuXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3RlbmVycy5cbiAgICAgKiBUaGlzIGlzIHdyaXRhYmxlIGZvciBjb3B5LW9uLXdyaXRlLlxuICAgICAqL1xuICAgIGxpc3RlbmVyczogTGlzdGVuZXJbXVxufVxuXG4vKipcbiAqIEZpbmQgdGhlIGluZGV4IG9mIGdpdmVuIGxpc3RlbmVyLlxuICogVGhpcyByZXR1cm5zIGAtMWAgaWYgbm90IGZvdW5kLlxuICogQHBhcmFtIGxpc3QgVGhlIGxpc3RlbmVyIGxpc3QuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpbmQuXG4gKiBAcGFyYW0gY2FwdHVyZSBUaGUgY2FwdHVyZSBmbGFnIHRvIGZpbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW5kZXhPZkxpc3RlbmVyKFxuICAgIHsgbGlzdGVuZXJzIH06IExpc3RlbmVyTGlzdCxcbiAgICBjYWxsYmFjazogTGlzdGVuZXIuQ2FsbGJhY2s8YW55LCBhbnk+LFxuICAgIGNhcHR1cmU6IGJvb2xlYW4sXG4pOiBudW1iZXIge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIGlzQ2FwdHVyZShsaXN0ZW5lcnNbaV0pID09PSBjYXB0dXJlXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIGxpc3RlbmVyLlxuICogRG9lcyBjb3B5LW9uLXdyaXRlIGlmIG5lZWRlZC5cbiAqIEBwYXJhbSBsaXN0IFRoZSBsaXN0ZW5lciBsaXN0LlxuICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSBjYXB0dXJlIFRoZSBjYXB0dXJlIGZsYWcuXG4gKiBAcGFyYW0gcGFzc2l2ZSBUaGUgcGFzc2l2ZSBmbGFnLlxuICogQHBhcmFtIG9uY2UgVGhlIG9uY2UgZmxhZy5cbiAqIEBwYXJhbSBzaWduYWwgVGhlIGFib3J0IHNpZ25hbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZExpc3RlbmVyKFxuICAgIGxpc3Q6IExpc3RlbmVyTGlzdCxcbiAgICBjYWxsYmFjazogTGlzdGVuZXIuQ2FsbGJhY2s8YW55LCBhbnk+LFxuICAgIGNhcHR1cmU6IGJvb2xlYW4sXG4gICAgcGFzc2l2ZTogYm9vbGVhbixcbiAgICBvbmNlOiBib29sZWFuLFxuICAgIHNpZ25hbDogTGlzdGVuZXIuQWJvcnRTaWduYWwgfCB1bmRlZmluZWQsXG4pOiBMaXN0ZW5lciB7XG4gICAgbGV0IHNpZ25hbExpc3RlbmVyOiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWRcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIHNpZ25hbExpc3RlbmVyID0gcmVtb3ZlTGlzdGVuZXIuYmluZChudWxsLCBsaXN0LCBjYWxsYmFjaywgY2FwdHVyZSlcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBzaWduYWxMaXN0ZW5lcilcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IGNyZWF0ZUxpc3RlbmVyKFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgY2FwdHVyZSxcbiAgICAgICAgcGFzc2l2ZSxcbiAgICAgICAgb25jZSxcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICBzaWduYWxMaXN0ZW5lcixcbiAgICApXG5cbiAgICBpZiAobGlzdC5jb3cpIHtcbiAgICAgICAgbGlzdC5jb3cgPSBmYWxzZVxuICAgICAgICBsaXN0Lmxpc3RlbmVycyA9IFsuLi5saXN0Lmxpc3RlbmVycywgbGlzdGVuZXJdXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcilcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdGVuZXJcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBsaXN0ZW5lci5cbiAqIEBwYXJhbSBsaXN0IFRoZSBsaXN0ZW5lciBsaXN0LlxuICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaW5kLlxuICogQHBhcmFtIGNhcHR1cmUgVGhlIGNhcHR1cmUgZmxhZyB0byBmaW5kLlxuICogQHJldHVybnMgYHRydWVgIGlmIGl0IG11dGF0ZWQgdGhlIGxpc3QgZGlyZWN0bHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihcbiAgICBsaXN0OiBMaXN0ZW5lckxpc3QsXG4gICAgY2FsbGJhY2s6IExpc3RlbmVyLkNhbGxiYWNrPGFueSwgYW55PixcbiAgICBjYXB0dXJlOiBib29sZWFuLFxuKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhPZkxpc3RlbmVyKGxpc3QsIGNhbGxiYWNrLCBjYXB0dXJlKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyQXQobGlzdCwgaW5kZXgpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIFJlbW92ZSBhIGxpc3RlbmVyLlxuICogQHBhcmFtIGxpc3QgVGhlIGxpc3RlbmVyIGxpc3QuXG4gKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YXJnZXQgbGlzdGVuZXIuXG4gKiBAcGFyYW0gZGlzYWJsZUNvdyBEaXNhYmxlIGNvcHktb24td3JpdGUgaWYgdHJ1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBpdCBtdXRhdGVkIHRoZSBgbGlzdGVuZXJzYCBhcnJheSBkaXJlY3RseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyQXQoXG4gICAgbGlzdDogTGlzdGVuZXJMaXN0LFxuICAgIGluZGV4OiBudW1iZXIsXG4gICAgZGlzYWJsZUNvdyA9IGZhbHNlLFxuKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBsaXN0Lmxpc3RlbmVyc1tpbmRleF1cblxuICAgIC8vIFNldCB0aGUgcmVtb3ZlZCBmbGFnLlxuICAgIHNldFJlbW92ZWQobGlzdGVuZXIpXG5cbiAgICAvLyBEaXNwb3NlIHRoZSBhYm9ydCBzaWduYWwgbGlzdGVuZXIgaWYgZXhpc3RzLlxuICAgIGlmIChsaXN0ZW5lci5zaWduYWwpIHtcbiAgICAgICAgbGlzdGVuZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lci5zaWduYWxMaXN0ZW5lciEpXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIGFycmF5LlxuICAgIGlmIChsaXN0LmNvdyAmJiAhZGlzYWJsZUNvdykge1xuICAgICAgICBsaXN0LmNvdyA9IGZhbHNlXG4gICAgICAgIGxpc3QubGlzdGVuZXJzID0gbGlzdC5saXN0ZW5lcnMuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGxpc3QubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSlcbiAgICByZXR1cm4gdHJ1ZVxufVxuIiwiaW1wb3J0IHsgTGlzdGVuZXJMaXN0IH0gZnJvbSBcIi4vbGlzdGVuZXItbGlzdFwiXG5cbi8qKlxuICogVGhlIG1hcCBmcm9tIGV2ZW50IHR5cGVzIHRvIGVhY2ggbGlzdGVuZXIgbGlzdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0ZW5lckxpc3RNYXAge1xuICAgIFt0eXBlOiBzdHJpbmddOiBMaXN0ZW5lckxpc3QgfCB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYExpc3RlbmVyTGlzdE1hcGAgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJMaXN0TWFwKCk6IExpc3RlbmVyTGlzdE1hcCB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGxpc3RlbmVyIGxpc3Qgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBJZiB0aGUgbGlzdGVuZXIgbGlzdCBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQsIGluaXRpYWxpemUgYW5kIHJldHVybiBpdC5cbiAqIEBwYXJhbSBsaXN0ZW5lck1hcCBUaGUgbGlzdGVuZXIgbGlzdCBtYXAuXG4gKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZSB0byBnZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVMaXN0ZW5lckxpc3QoXG4gICAgbGlzdGVuZXJNYXA6IFJlY29yZDxzdHJpbmcsIExpc3RlbmVyTGlzdCB8IHVuZGVmaW5lZD4sXG4gICAgdHlwZTogc3RyaW5nLFxuKTogTGlzdGVuZXJMaXN0IHtcbiAgICByZXR1cm4gKGxpc3RlbmVyTWFwW3R5cGVdID8/PSB7XG4gICAgICAgIGF0dHJDYWxsYmFjazogdW5kZWZpbmVkLFxuICAgICAgICBhdHRyTGlzdGVuZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgY293OiBmYWxzZSxcbiAgICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICB9KVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IgfSBmcm9tIFwiLi9kb20tZXhjZXB0aW9uXCJcbmltcG9ydCB7IEV2ZW50LCBnZXRFdmVudEludGVybmFsRGF0YSB9IGZyb20gXCIuL2V2ZW50XCJcbmltcG9ydCB7IEV2ZW50V3JhcHBlciB9IGZyb20gXCIuL2V2ZW50LXdyYXBwZXJcIlxuaW1wb3J0IHsgR2xvYmFsIH0gZnJvbSBcIi4vZ2xvYmFsXCJcbmltcG9ydCB7XG4gICAgaW52b2tlQ2FsbGJhY2ssXG4gICAgaXNDYXB0dXJlLFxuICAgIGlzT25jZSxcbiAgICBpc1Bhc3NpdmUsXG4gICAgaXNSZW1vdmVkLFxuICAgIExpc3RlbmVyLFxufSBmcm9tIFwiLi9saXN0ZW5lclwiXG5pbXBvcnQge1xuICAgIGFkZExpc3RlbmVyLFxuICAgIGZpbmRJbmRleE9mTGlzdGVuZXIsXG4gICAgcmVtb3ZlTGlzdGVuZXIsXG4gICAgcmVtb3ZlTGlzdGVuZXJBdCxcbn0gZnJvbSBcIi4vbGlzdGVuZXItbGlzdFwiXG5pbXBvcnQge1xuICAgIGNyZWF0ZUxpc3RlbmVyTGlzdE1hcCxcbiAgICBlbnN1cmVMaXN0ZW5lckxpc3QsXG4gICAgTGlzdGVuZXJMaXN0TWFwLFxufSBmcm9tIFwiLi9saXN0ZW5lci1saXN0LW1hcFwiXG5pbXBvcnQgeyBhc3NlcnRUeXBlLCBmb3JtYXQgfSBmcm9tIFwiLi9taXNjXCJcbmltcG9ydCB7XG4gICAgRXZlbnRMaXN0ZW5lcldhc0R1cGxpY2F0ZWQsXG4gICAgSW52YWxpZEV2ZW50TGlzdGVuZXIsXG4gICAgT3B0aW9uV2FzSWdub3JlZCxcbn0gZnJvbSBcIi4vd2FybmluZ3NcIlxuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgRXZlbnRUYXJnZXRgIGludGVyZmFjZS5cbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNldmVudHRhcmdldFxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRUYXJnZXQ8XG4gICAgVEV2ZW50TWFwIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgRXZlbnQ+ID0gUmVjb3JkPHN0cmluZywgRXZlbnQ+LFxuICAgIFRNb2RlIGV4dGVuZHMgXCJzdGFuZGFyZFwiIHwgXCJzdHJpY3RcIiA9IFwic3RhbmRhcmRcIlxuPiB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGlzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBpbnRlcm5hbERhdGFNYXAuc2V0KHRoaXMsIGNyZWF0ZUxpc3RlbmVyTGlzdE1hcCgpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgVEV2ZW50TWFwPihcbiAgICAgICAgdHlwZTogVCxcbiAgICAgICAgY2FsbGJhY2s/OiBFdmVudFRhcmdldC5FdmVudExpc3RlbmVyPHRoaXMsIFRFdmVudE1hcFtUXT4gfCBudWxsLFxuICAgICAgICBvcHRpb25zPzogRXZlbnRUYXJnZXQuQWRkT3B0aW9ucyxcbiAgICApOiB2b2lkXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLlxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIHR5cGU6IHN0cmluZyxcbiAgICAgICAgY2FsbGJhY2s/OiBFdmVudFRhcmdldC5GYWxsYmFja0V2ZW50TGlzdGVuZXI8dGhpcywgVE1vZGU+LFxuICAgICAgICBvcHRpb25zPzogRXZlbnRUYXJnZXQuQWRkT3B0aW9ucyxcbiAgICApOiB2b2lkXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gY2FwdHVyZSBUaGUgY2FwdHVyZSBmbGFnLlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBge2NhcHR1cmU6IGJvb2xlYW59YCBvYmplY3QgaW5zdGVhZCBvZiBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgVEV2ZW50TWFwPihcbiAgICAgICAgdHlwZTogVCxcbiAgICAgICAgY2FsbGJhY2s6XG4gICAgICAgICAgICB8IEV2ZW50VGFyZ2V0LkV2ZW50TGlzdGVuZXI8dGhpcywgVEV2ZW50TWFwW1RdPlxuICAgICAgICAgICAgfCBudWxsXG4gICAgICAgICAgICB8IHVuZGVmaW5lZCxcbiAgICAgICAgY2FwdHVyZTogYm9vbGVhbixcbiAgICApOiB2b2lkXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gY2FwdHVyZSBUaGUgY2FwdHVyZSBmbGFnLlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBge2NhcHR1cmU6IGJvb2xlYW59YCBvYmplY3QgaW5zdGVhZCBvZiBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgdHlwZTogc3RyaW5nLFxuICAgICAgICBjYWxsYmFjazogRXZlbnRUYXJnZXQuRmFsbGJhY2tFdmVudExpc3RlbmVyPHRoaXMsIFRNb2RlPixcbiAgICAgICAgY2FwdHVyZTogYm9vbGVhbixcbiAgICApOiB2b2lkXG5cbiAgICAvLyBJbXBsZW1lbnRhdGlvblxuICAgIGFkZEV2ZW50TGlzdGVuZXI8VCBleHRlbmRzIHN0cmluZyAmIGtleW9mIFRFdmVudE1hcD4oXG4gICAgICAgIHR5cGUwOiBULFxuICAgICAgICBjYWxsYmFjazA/OiBFdmVudFRhcmdldC5FdmVudExpc3RlbmVyPHRoaXMsIFRFdmVudE1hcFtUXT4gfCBudWxsLFxuICAgICAgICBvcHRpb25zMD86IGJvb2xlYW4gfCBFdmVudFRhcmdldC5BZGRPcHRpb25zLFxuICAgICk6IHZvaWQge1xuICAgICAgICBjb25zdCBsaXN0ZW5lck1hcCA9ICQodGhpcylcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBjYXB0dXJlLFxuICAgICAgICAgICAgb25jZSxcbiAgICAgICAgICAgIHBhc3NpdmUsXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9ID0gbm9ybWFsaXplQWRkT3B0aW9ucyh0eXBlMCwgY2FsbGJhY2swLCBvcHRpb25zMClcbiAgICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwgfHwgc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ID0gZW5zdXJlTGlzdGVuZXJMaXN0KGxpc3RlbmVyTWFwLCB0eXBlKVxuXG4gICAgICAgIC8vIEZpbmQgZXhpc3RpbmcgbGlzdGVuZXIuXG4gICAgICAgIGNvbnN0IGkgPSBmaW5kSW5kZXhPZkxpc3RlbmVyKGxpc3QsIGNhbGxiYWNrLCBjYXB0dXJlKVxuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHdhcm5EdXBsaWNhdGUobGlzdC5saXN0ZW5lcnNbaV0sIHBhc3NpdmUsIG9uY2UsIHNpZ25hbClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgbGlzdGVuZXIuXG4gICAgICAgIGFkZExpc3RlbmVyKGxpc3QsIGNhbGxiYWNrLCBjYXB0dXJlLCBwYXNzaXZlLCBvbmNlLCBzaWduYWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGFkZGVkIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucy5cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBURXZlbnRNYXA+KFxuICAgICAgICB0eXBlOiBULFxuICAgICAgICBjYWxsYmFjaz86IEV2ZW50VGFyZ2V0LkV2ZW50TGlzdGVuZXI8dGhpcywgVEV2ZW50TWFwW1RdPiB8IG51bGwsXG4gICAgICAgIG9wdGlvbnM/OiBFdmVudFRhcmdldC5PcHRpb25zLFxuICAgICk6IHZvaWRcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBhZGRlZCBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMuXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgdHlwZTogc3RyaW5nLFxuICAgICAgICBjYWxsYmFjaz86IEV2ZW50VGFyZ2V0LkZhbGxiYWNrRXZlbnRMaXN0ZW5lcjx0aGlzLCBUTW9kZT4sXG4gICAgICAgIG9wdGlvbnM/OiBFdmVudFRhcmdldC5PcHRpb25zLFxuICAgICk6IHZvaWRcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBhZGRlZCBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBjYXB0dXJlIFRoZSBjYXB0dXJlIGZsYWcuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGB7Y2FwdHVyZTogYm9vbGVhbn1gIG9iamVjdCBpbnN0ZWFkIG9mIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBURXZlbnRNYXA+KFxuICAgICAgICB0eXBlOiBULFxuICAgICAgICBjYWxsYmFjazpcbiAgICAgICAgICAgIHwgRXZlbnRUYXJnZXQuRXZlbnRMaXN0ZW5lcjx0aGlzLCBURXZlbnRNYXBbVF0+XG4gICAgICAgICAgICB8IG51bGxcbiAgICAgICAgICAgIHwgdW5kZWZpbmVkLFxuICAgICAgICBjYXB0dXJlOiBib29sZWFuLFxuICAgICk6IHZvaWRcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBhZGRlZCBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBjYXB0dXJlIFRoZSBjYXB0dXJlIGZsYWcuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGB7Y2FwdHVyZTogYm9vbGVhbn1gIG9iamVjdCBpbnN0ZWFkIG9mIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgIGNhbGxiYWNrOiBFdmVudFRhcmdldC5GYWxsYmFja0V2ZW50TGlzdGVuZXI8dGhpcywgVE1vZGU+LFxuICAgICAgICBjYXB0dXJlOiBib29sZWFuLFxuICAgICk6IHZvaWRcblxuICAgIC8vIEltcGxlbWVudGF0aW9uXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgVEV2ZW50TWFwPihcbiAgICAgICAgdHlwZTA6IFQsXG4gICAgICAgIGNhbGxiYWNrMD86IEV2ZW50VGFyZ2V0LkV2ZW50TGlzdGVuZXI8dGhpcywgVEV2ZW50TWFwW1RdPiB8IG51bGwsXG4gICAgICAgIG9wdGlvbnMwPzogYm9vbGVhbiB8IEV2ZW50VGFyZ2V0Lk9wdGlvbnMsXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyTWFwID0gJCh0aGlzKVxuICAgICAgICBjb25zdCB7IGNhbGxiYWNrLCBjYXB0dXJlLCB0eXBlIH0gPSBub3JtYWxpemVPcHRpb25zKFxuICAgICAgICAgICAgdHlwZTAsXG4gICAgICAgICAgICBjYWxsYmFjazAsXG4gICAgICAgICAgICBvcHRpb25zMCxcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBsaXN0ID0gbGlzdGVuZXJNYXBbdHlwZV1cblxuICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiBsaXN0KSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0LCBjYWxsYmFjaywgY2FwdHVyZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgYEV2ZW50YCBvYmplY3QgdG8gZGlzcGF0Y2guXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudDxUIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgVEV2ZW50TWFwPihcbiAgICAgICAgZXZlbnQ6IEV2ZW50VGFyZ2V0LkV2ZW50RGF0YTxURXZlbnRNYXAsIFRNb2RlLCBUPixcbiAgICApOiBib29sZWFuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGBFdmVudGAgb2JqZWN0IHRvIGRpc3BhdGNoLlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQ6IEV2ZW50VGFyZ2V0LkZhbGxiYWNrRXZlbnQ8VE1vZGU+KTogYm9vbGVhblxuXG4gICAgLy8gSW1wbGVtZW50YXRpb25cbiAgICBkaXNwYXRjaEV2ZW50KFxuICAgICAgICBlOlxuICAgICAgICAgICAgfCBFdmVudFRhcmdldC5FdmVudERhdGE8VEV2ZW50TWFwLCBUTW9kZSwgc3RyaW5nPlxuICAgICAgICAgICAgfCBFdmVudFRhcmdldC5GYWxsYmFja0V2ZW50PFRNb2RlPixcbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgbGlzdCA9ICQodGhpcylbU3RyaW5nKGUudHlwZSldXG4gICAgICAgIGlmIChsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBldmVudCA9IGUgaW5zdGFuY2VvZiBFdmVudCA/IGUgOiBFdmVudFdyYXBwZXIud3JhcChlKVxuICAgICAgICBjb25zdCBldmVudERhdGEgPSBnZXRFdmVudEludGVybmFsRGF0YShldmVudCwgXCJldmVudFwiKVxuICAgICAgICBpZiAoZXZlbnREYXRhLmRpc3BhdGNoRmxhZykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoXCJUaGlzIGV2ZW50IGhhcyBiZWVuIGluIGRpc3BhdGNoaW5nLlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnREYXRhLmRpc3BhdGNoRmxhZyA9IHRydWVcbiAgICAgICAgZXZlbnREYXRhLnRhcmdldCA9IGV2ZW50RGF0YS5jdXJyZW50VGFyZ2V0ID0gdGhpc1xuXG4gICAgICAgIGlmICghZXZlbnREYXRhLnN0b3BQcm9wYWdhdGlvbkZsYWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY293LCBsaXN0ZW5lcnMgfSA9IGxpc3RcblxuICAgICAgICAgICAgLy8gU2V0IGNvcHktb24td3JpdGUgZmxhZy5cbiAgICAgICAgICAgIGxpc3QuY293ID0gdHJ1ZVxuXG4gICAgICAgICAgICAvLyBDYWxsIGxpc3RlbmVycy5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV1cblxuICAgICAgICAgICAgICAgIC8vIFNraXAgaWYgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICBpZiAoaXNSZW1vdmVkKGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGxpc3RlbmVyIGlmIGhhcyB0aGUgYG9uY2VgIGZsYWcuXG4gICAgICAgICAgICAgICAgaWYgKGlzT25jZShsaXN0ZW5lcikgJiYgcmVtb3ZlTGlzdGVuZXJBdChsaXN0LCBpLCAhY293KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoaXMgbGlzdGVuZXIgd2FzIHJlbW92ZWQsIHRoZSBuZXh0IGluZGV4IGlzIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBzYW1lIGFzIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBpIC09IDFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoaXMgbGlzdGVuZXIgd2l0aCB0aGUgYHBhc3NpdmVgIGZsYWcuXG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLmluUGFzc2l2ZUxpc3RlbmVyRmxhZyA9IGlzUGFzc2l2ZShsaXN0ZW5lcilcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhsaXN0ZW5lciwgdGhpcywgZXZlbnQpXG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLmluUGFzc2l2ZUxpc3RlbmVyRmxhZyA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICAvLyBTdG9wIGlmIHRoZSBgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClgIG1ldGhvZCB3YXMgY2FsbGVkLlxuICAgICAgICAgICAgICAgIGlmIChldmVudERhdGEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uRmxhZykge1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzdG9yZSBjb3B5LW9uLXdyaXRlIGZsYWcuXG4gICAgICAgICAgICBpZiAoIWNvdykge1xuICAgICAgICAgICAgICAgIGxpc3QuY293ID0gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50RGF0YS50YXJnZXQgPSBudWxsXG4gICAgICAgIGV2ZW50RGF0YS5jdXJyZW50VGFyZ2V0ID0gbnVsbFxuICAgICAgICBldmVudERhdGEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uRmxhZyA9IGZhbHNlXG4gICAgICAgIGV2ZW50RGF0YS5zdG9wUHJvcGFnYXRpb25GbGFnID0gZmFsc2VcbiAgICAgICAgZXZlbnREYXRhLmRpc3BhdGNoRmxhZyA9IGZhbHNlXG5cbiAgICAgICAgcmV0dXJuICFldmVudERhdGEuY2FuY2VsZWRGbGFnXG4gICAgfVxufVxuXG5leHBvcnQgbmFtZXNwYWNlIEV2ZW50VGFyZ2V0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgZXhwb3J0IHR5cGUgRXZlbnRMaXN0ZW5lcjxcbiAgICAgICAgVEV2ZW50VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQ8YW55LCBhbnk+LFxuICAgICAgICBURXZlbnQgZXh0ZW5kcyBFdmVudFxuICAgID4gPSBDYWxsYmFja0Z1bmN0aW9uPFRFdmVudFRhcmdldCwgVEV2ZW50PiB8IENhbGxiYWNrT2JqZWN0PFRFdmVudD5cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIENhbGxiYWNrRnVuY3Rpb248XG4gICAgICAgIFRFdmVudFRhcmdldCBleHRlbmRzIEV2ZW50VGFyZ2V0PGFueSwgYW55PixcbiAgICAgICAgVEV2ZW50IGV4dGVuZHMgRXZlbnRcbiAgICA+IHtcbiAgICAgICAgKHRoaXM6IFRFdmVudFRhcmdldCwgZXZlbnQ6IFRFdmVudCk6IHZvaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgbGlzdGVuZXIgb2JqZWN0LlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjYWxsYmFja2RlZi1ldmVudGxpc3RlbmVyXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBDYWxsYmFja09iamVjdDxURXZlbnQgZXh0ZW5kcyBFdmVudD4ge1xuICAgICAgICBoYW5kbGVFdmVudChldmVudDogVEV2ZW50KTogdm9pZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21tb24gb3B0aW9ucyBmb3IgYm90aCBgYWRkRXZlbnRMaXN0ZW5lcmAgYW5kIGByZW1vdmVFdmVudExpc3RlbmVyYCBtZXRob2RzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkaWN0ZGVmLWV2ZW50bGlzdGVuZXJvcHRpb25zXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBPcHRpb25zIHtcbiAgICAgICAgY2FwdHVyZT86IGJvb2xlYW5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyBmb3IgdGhlIGBhZGRFdmVudExpc3RlbmVyYCBtZXRob2RzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkaWN0ZGVmLWFkZGV2ZW50bGlzdGVuZXJvcHRpb25zXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBBZGRPcHRpb25zIGV4dGVuZHMgT3B0aW9ucyB7XG4gICAgICAgIHBhc3NpdmU/OiBib29sZWFuXG4gICAgICAgIG9uY2U/OiBib29sZWFuXG4gICAgICAgIHNpZ25hbD86IEFib3J0U2lnbmFsIHwgbnVsbCB8IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhYm9ydCBzaWduYWwuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2Fib3J0c2lnbmFsXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBBYm9ydFNpZ25hbCBleHRlbmRzIEV2ZW50VGFyZ2V0PHsgYWJvcnQ6IEV2ZW50IH0+IHtcbiAgICAgICAgcmVhZG9ubHkgYWJvcnRlZDogYm9vbGVhblxuICAgICAgICBvbmFib3J0OiBDYWxsYmFja0Z1bmN0aW9uPHRoaXMsIEV2ZW50PiB8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgZGF0YSB0byBkaXNwYXRjaCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgKi9cbiAgICBleHBvcnQgdHlwZSBFdmVudERhdGE8XG4gICAgICAgIFRFdmVudE1hcCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIEV2ZW50PixcbiAgICAgICAgVE1vZGUgZXh0ZW5kcyBcInN0YW5kYXJkXCIgfCBcInN0cmljdFwiLFxuICAgICAgICBURXZlbnRUeXBlIGV4dGVuZHMgc3RyaW5nXG4gICAgPiA9IFRNb2RlIGV4dGVuZHMgXCJzdHJpY3RcIlxuICAgICAgICA/IElzVmFsaWRFdmVudE1hcDxURXZlbnRNYXA+IGV4dGVuZHMgdHJ1ZVxuICAgICAgICAgICAgPyBFeHBsaWNpdFR5cGU8VEV2ZW50VHlwZT4gJlxuICAgICAgICAgICAgICAgICAgT21pdDxURXZlbnRNYXBbVEV2ZW50VHlwZV0sIGtleW9mIEV2ZW50PiAmXG4gICAgICAgICAgICAgICAgICBQYXJ0aWFsPE9taXQ8RXZlbnQsIFwidHlwZVwiPj5cbiAgICAgICAgICAgIDogbmV2ZXJcbiAgICAgICAgOiBuZXZlclxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIGV4cGxpY2l0IGB0eXBlYCBwcm9wZXJ0eSBpZiBgVGAgaXMgYSBzdHJpbmcgbGl0ZXJhbC5cbiAgICAgKiBPdGhlcndpc2UsIG5ldmVyLlxuICAgICAqL1xuICAgIGV4cG9ydCB0eXBlIEV4cGxpY2l0VHlwZTxUIGV4dGVuZHMgc3RyaW5nPiA9IHN0cmluZyBleHRlbmRzIFRcbiAgICAgICAgPyBuZXZlclxuICAgICAgICA6IHsgcmVhZG9ubHkgdHlwZTogVCB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgbGlzdGVuZXIgdHlwZSBpbiBzdGFuZGFyZCBtb2RlLlxuICAgICAqIE90aGVyd2lzZSwgbmV2ZXIuXG4gICAgICovXG4gICAgZXhwb3J0IHR5cGUgRmFsbGJhY2tFdmVudExpc3RlbmVyPFxuICAgICAgICBURXZlbnRUYXJnZXQgZXh0ZW5kcyBFdmVudFRhcmdldDxhbnksIGFueT4sXG4gICAgICAgIFRNb2RlIGV4dGVuZHMgXCJzdGFuZGFyZFwiIHwgXCJzdHJpY3RcIlxuICAgID4gPSBUTW9kZSBleHRlbmRzIFwic3RhbmRhcmRcIlxuICAgICAgICA/IEV2ZW50TGlzdGVuZXI8VEV2ZW50VGFyZ2V0LCBFdmVudD4gfCBudWxsIHwgdW5kZWZpbmVkXG4gICAgICAgIDogbmV2ZXJcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCB0eXBlIGluIHN0YW5kYXJkIG1vZGUuXG4gICAgICogT3RoZXJ3aXNlLCBuZXZlci5cbiAgICAgKi9cbiAgICBleHBvcnQgdHlwZSBGYWxsYmFja0V2ZW50PFxuICAgICAgICBUTW9kZSBleHRlbmRzIFwic3RhbmRhcmRcIiB8IFwic3RyaWN0XCJcbiAgICA+ID0gVE1vZGUgZXh0ZW5kcyBcInN0YW5kYXJkXCIgPyBFdmVudCA6IG5ldmVyXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBnaXZlbiBldmVudCBtYXAgaXMgdmFsaWQuXG4gICAgICogSXQncyB2YWxpZCBpZiB0aGUga2V5cyBvZiB0aGUgZXZlbnQgbWFwIGFyZSBuYXJyb3dlciB0aGFuIGBzdHJpbmdgLlxuICAgICAqL1xuICAgIGV4cG9ydCB0eXBlIElzVmFsaWRFdmVudE1hcDxUPiA9IHN0cmluZyBleHRlbmRzIGtleW9mIFQgPyBmYWxzZSA6IHRydWVcbn1cblxuZXhwb3J0IHsgJCBhcyBnZXRFdmVudFRhcmdldEludGVybmFsRGF0YSB9XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEludGVybmFsIGRhdGEgZm9yIEV2ZW50VGFyZ2V0XG4gKi9cbnR5cGUgRXZlbnRUYXJnZXRJbnRlcm5hbERhdGEgPSBMaXN0ZW5lckxpc3RNYXBcblxuLyoqXG4gKiBJbnRlcm5hbCBkYXRhLlxuICovXG5jb25zdCBpbnRlcm5hbERhdGFNYXAgPSBuZXcgV2Vha01hcDxhbnksIEV2ZW50VGFyZ2V0SW50ZXJuYWxEYXRhPigpXG5cbi8qKlxuICogR2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvYmplY3QgdG8gZ2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSBuYW1lIFRoZSB2YXJpYWJsZSBuYW1lIHRvIHJlcG9ydC5cbiAqIEByZXR1cm5zIFRoZSBwcml2YXRlIGRhdGEgb2YgdGhlIGV2ZW50LlxuICovXG5mdW5jdGlvbiAkKHRhcmdldDogYW55LCBuYW1lID0gXCJ0aGlzXCIpOiBFdmVudFRhcmdldEludGVybmFsRGF0YSB7XG4gICAgY29uc3QgcmV0diA9IGludGVybmFsRGF0YU1hcC5nZXQodGFyZ2V0KVxuICAgIGFzc2VydFR5cGUoXG4gICAgICAgIHJldHYgIT0gbnVsbCxcbiAgICAgICAgXCInJXMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgRXZlbnRUYXJnZXQgY29uc3RydWN0b3IgY3JlYXRlZCwgYnV0IGdvdCBhbm90aGVyIG9uZTogJW9cIixcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgIClcbiAgICByZXR1cm4gcmV0dlxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBZGRPcHRpb25zKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBjYWxsYmFjazogRXZlbnRUYXJnZXQuRXZlbnRMaXN0ZW5lcjxhbnksIGFueT4gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM6IGJvb2xlYW4gfCBFdmVudFRhcmdldC5BZGRPcHRpb25zIHwgdW5kZWZpbmVkLFxuKToge1xuICAgIHR5cGU6IHN0cmluZ1xuICAgIGNhbGxiYWNrOiBFdmVudFRhcmdldC5FdmVudExpc3RlbmVyPGFueSwgYW55PiB8IHVuZGVmaW5lZFxuICAgIGNhcHR1cmU6IGJvb2xlYW5cbiAgICBwYXNzaXZlOiBib29sZWFuXG4gICAgb25jZTogYm9vbGVhblxuICAgIHNpZ25hbDogRXZlbnRUYXJnZXQuQWJvcnRTaWduYWwgfCB1bmRlZmluZWRcbn0ge1xuICAgIGFzc2VydENhbGxiYWNrKGNhbGxiYWNrKVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyh0eXBlKSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBjYXB0dXJlOiBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSksXG4gICAgICAgICAgICBwYXNzaXZlOiBCb29sZWFuKG9wdGlvbnMucGFzc2l2ZSksXG4gICAgICAgICAgICBvbmNlOiBCb29sZWFuKG9wdGlvbnMub25jZSksXG4gICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsID8/IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyh0eXBlKSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrID8/IHVuZGVmaW5lZCxcbiAgICAgICAgY2FwdHVyZTogQm9vbGVhbihvcHRpb25zKSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIG9uY2U6IGZhbHNlLFxuICAgICAgICBzaWduYWw6IHVuZGVmaW5lZCxcbiAgICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyB0byBub3JtYWxpemUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiBFdmVudFRhcmdldC5FdmVudExpc3RlbmVyPGFueSwgYW55PiB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogYm9vbGVhbiB8IEV2ZW50VGFyZ2V0Lk9wdGlvbnMgfCB1bmRlZmluZWQsXG4pOiB7XG4gICAgdHlwZTogc3RyaW5nXG4gICAgY2FsbGJhY2s6IEV2ZW50VGFyZ2V0LkV2ZW50TGlzdGVuZXI8YW55LCBhbnk+IHwgdW5kZWZpbmVkXG4gICAgY2FwdHVyZTogYm9vbGVhblxufSB7XG4gICAgYXNzZXJ0Q2FsbGJhY2soY2FsbGJhY2spXG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nKHR5cGUpLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNhcHR1cmU6IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKSxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyh0eXBlKSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrID8/IHVuZGVmaW5lZCxcbiAgICAgICAgY2FwdHVyZTogQm9vbGVhbihvcHRpb25zKSxcbiAgICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoZSB0eXBlIG9mICdjYWxsYmFjaycgYXJndW1lbnQuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBhc3NlcnRDYWxsYmFjayhjYWxsYmFjazogYW55KTogdm9pZCB7XG4gICAgaWYgKFxuICAgICAgICB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICAodHlwZW9mIGNhbGxiYWNrID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBjYWxsYmFjayAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGNhbGxiYWNrLmhhbmRsZUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpXG4gICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgSW52YWxpZEV2ZW50TGlzdGVuZXIud2FybihjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmb3JtYXQoSW52YWxpZEV2ZW50TGlzdGVuZXIubWVzc2FnZSwgW2NhbGxiYWNrXSkpXG59XG5cbi8qKlxuICogUHJpbnQgd2FybmluZyBmb3IgZHVwbGljYXRlZC5cbiAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgY3VycmVudCBsaXN0ZW5lciB0aGF0IGlzIGR1cGxpY2F0ZWQuXG4gKiBAcGFyYW0gcGFzc2l2ZSBUaGUgcGFzc2l2ZSBmbGFnIG9mIHRoZSBuZXcgZHVwbGljYXRlZCBsaXN0ZW5lci5cbiAqIEBwYXJhbSBvbmNlIFRoZSBvbmNlIGZsYWcgb2YgdGhlIG5ldyBkdXBsaWNhdGVkIGxpc3RlbmVyLlxuICogQHBhcmFtIHNpZ25hbCBUaGUgc2lnbmFsIG9iamVjdCBvZiB0aGUgbmV3IGR1cGxpY2F0ZWQgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIHdhcm5EdXBsaWNhdGUoXG4gICAgbGlzdGVuZXI6IExpc3RlbmVyLFxuICAgIHBhc3NpdmU6IGJvb2xlYW4sXG4gICAgb25jZTogYm9vbGVhbixcbiAgICBzaWduYWw6IEV2ZW50VGFyZ2V0LkFib3J0U2lnbmFsIHwgdW5kZWZpbmVkLFxuKTogdm9pZCB7XG4gICAgRXZlbnRMaXN0ZW5lcldhc0R1cGxpY2F0ZWQud2FybihcbiAgICAgICAgaXNDYXB0dXJlKGxpc3RlbmVyKSA/IFwiY2FwdHVyZVwiIDogXCJidWJibGVcIixcbiAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2ssXG4gICAgKVxuXG4gICAgaWYgKGlzUGFzc2l2ZShsaXN0ZW5lcikgIT09IHBhc3NpdmUpIHtcbiAgICAgICAgT3B0aW9uV2FzSWdub3JlZC53YXJuKFwicGFzc2l2ZVwiKVxuICAgIH1cbiAgICBpZiAoaXNPbmNlKGxpc3RlbmVyKSAhPT0gb25jZSkge1xuICAgICAgICBPcHRpb25XYXNJZ25vcmVkLndhcm4oXCJvbmNlXCIpXG4gICAgfVxuICAgIGlmIChsaXN0ZW5lci5zaWduYWwgIT09IHNpZ25hbCkge1xuICAgICAgICBPcHRpb25XYXNJZ25vcmVkLndhcm4oXCJzaWduYWxcIilcbiAgICB9XG59XG5cbi8vIFNldCBlbnVtZXJhYmxlXG5jb25zdCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoRXZlbnRUYXJnZXQucHJvdG90eXBlKVxuZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGtleXNbaV0gPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICBjb250aW51ZVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRUYXJnZXQucHJvdG90eXBlLCBrZXlzW2ldLCB7IGVudW1lcmFibGU6IHRydWUgfSlcbn1cblxuLy8gRW5zdXJlIGBldmVudFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudFRhcmdldGAgaXMgYHRydWVgLlxuaWYgKFxuICAgIHR5cGVvZiBHbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgR2xvYmFsLkV2ZW50VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiXG4pIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnRUYXJnZXQucHJvdG90eXBlLCBHbG9iYWwuRXZlbnRUYXJnZXQucHJvdG90eXBlKVxufVxuIiwiaW1wb3J0IHsgRXZlbnQgfSBmcm9tIFwiLi9ldmVudFwiXG5pbXBvcnQgeyBFdmVudFRhcmdldCwgZ2V0RXZlbnRUYXJnZXRJbnRlcm5hbERhdGEgfSBmcm9tIFwiLi9ldmVudC10YXJnZXRcIlxuaW1wb3J0IHsgYWRkTGlzdGVuZXIsIExpc3RlbmVyTGlzdCwgcmVtb3ZlTGlzdGVuZXIgfSBmcm9tIFwiLi9saXN0ZW5lci1saXN0XCJcbmltcG9ydCB7IGVuc3VyZUxpc3RlbmVyTGlzdCB9IGZyb20gXCIuL2xpc3RlbmVyLWxpc3QtbWFwXCJcbmltcG9ydCB7IEludmFsaWRBdHRyaWJ1dGVIYW5kbGVyIH0gZnJvbSBcIi4vd2FybmluZ3NcIlxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIGdpdmVuIGV2ZW50IGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGBFdmVudFRhcmdldGAgb2JqZWN0IHRvIGdldC5cbiAqIEBwYXJhbSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZTxcbiAgICBURXZlbnRUYXJnZXQgZXh0ZW5kcyBFdmVudFRhcmdldDxhbnksIGFueT4sXG4gICAgVEV2ZW50IGV4dGVuZHMgRXZlbnRcbj4oXG4gICAgdGFyZ2V0OiBURXZlbnRUYXJnZXQsXG4gICAgdHlwZTogc3RyaW5nLFxuKTogRXZlbnRUYXJnZXQuQ2FsbGJhY2tGdW5jdGlvbjxURXZlbnRUYXJnZXQsIFRFdmVudD4gfCBudWxsIHtcbiAgICBjb25zdCBsaXN0TWFwID0gZ2V0RXZlbnRUYXJnZXRJbnRlcm5hbERhdGEodGFyZ2V0LCBcInRhcmdldFwiKVxuICAgIHJldHVybiBsaXN0TWFwW3R5cGVdPy5hdHRyQ2FsbGJhY2sgPz8gbnVsbFxufVxuXG4vKipcbiAqIFNldCBhbiBldmVudCBsaXN0ZW5lciB0byBhIGdpdmVuIGV2ZW50IGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGBFdmVudFRhcmdldGAgb2JqZWN0IHRvIHNldC5cbiAqIEBwYXJhbSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIGNhbGxiYWNrIFRoZSBldmVudCBsaXN0ZW5lci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEV2ZW50QXR0cmlidXRlVmFsdWUoXG4gICAgdGFyZ2V0OiBFdmVudFRhcmdldDxhbnksIGFueT4sXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiBFdmVudFRhcmdldC5DYWxsYmFja0Z1bmN0aW9uPGFueSwgYW55PiB8IG51bGwsXG4pOiB2b2lkIHtcbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBJbnZhbGlkQXR0cmlidXRlSGFuZGxlci53YXJuKGNhbGxiYWNrKVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJvYmplY3RcIiAmJiBjYWxsYmFjayAhPT0gbnVsbClcbiAgICApIHtcbiAgICAgICAgdXBzZXJ0RXZlbnRBdHRyaWJ1dGVMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUV2ZW50QXR0cmlidXRlTGlzdGVuZXIodGFyZ2V0LCB0eXBlKVxuICAgIH1cbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhlbHBlcnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVXBkYXRlIG9yIGluc2VydCB0aGUgZ2l2ZW4gZXZlbnQgYXR0cmlidXRlIGhhbmRsZXIuXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBgRXZlbnRUYXJnZXRgIG9iamVjdCB0byBzZXQuXG4gKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZXZlbnQgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIHVwc2VydEV2ZW50QXR0cmlidXRlTGlzdGVuZXI8XG4gICAgVEV2ZW50VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQ8YW55LCBhbnk+XG4+KFxuICAgIHRhcmdldDogVEV2ZW50VGFyZ2V0LFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBjYWxsYmFjazogRXZlbnRUYXJnZXQuQ2FsbGJhY2tGdW5jdGlvbjxURXZlbnRUYXJnZXQsIGFueT4sXG4pOiB2b2lkIHtcbiAgICBjb25zdCBsaXN0ID0gZW5zdXJlTGlzdGVuZXJMaXN0KFxuICAgICAgICBnZXRFdmVudFRhcmdldEludGVybmFsRGF0YSh0YXJnZXQsIFwidGFyZ2V0XCIpLFxuICAgICAgICBTdHJpbmcodHlwZSksXG4gICAgKVxuICAgIGxpc3QuYXR0ckNhbGxiYWNrID0gY2FsbGJhY2tcblxuICAgIGlmIChsaXN0LmF0dHJMaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgIGxpc3QuYXR0ckxpc3RlbmVyID0gYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICBsaXN0LFxuICAgICAgICAgICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGVDYWxsYmFjayhsaXN0KSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgKVxuICAgIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGV2ZW50IGF0dHJpYnV0ZSBoYW5kbGVyLlxuICogQHBhcmFtIHRhcmdldCBUaGUgYEV2ZW50VGFyZ2V0YCBvYmplY3QgdG8gcmVtb3ZlLlxuICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudEF0dHJpYnV0ZUxpc3RlbmVyKFxuICAgIHRhcmdldDogRXZlbnRUYXJnZXQ8YW55LCBhbnk+LFxuICAgIHR5cGU6IHN0cmluZyxcbik6IHZvaWQge1xuICAgIGNvbnN0IGxpc3RNYXAgPSBnZXRFdmVudFRhcmdldEludGVybmFsRGF0YSh0YXJnZXQsIFwidGFyZ2V0XCIpXG4gICAgY29uc3QgbGlzdCA9IGxpc3RNYXBbU3RyaW5nKHR5cGUpXVxuICAgIGlmIChsaXN0ICYmIGxpc3QuYXR0ckxpc3RlbmVyKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3QsIGxpc3QuYXR0ckxpc3RlbmVyLmNhbGxiYWNrLCBmYWxzZSlcbiAgICAgICAgbGlzdC5hdHRyQ2FsbGJhY2sgPSBsaXN0LmF0dHJMaXN0ZW5lciA9IHVuZGVmaW5lZFxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbGlzdGVuZXIgbGlzdCBvYmplY3QuXG4gKiBJdCBjYWxscyBgYXR0ckNhbGxiYWNrYCBwcm9wZXJ0eSBpZiB0aGUgcHJvcGVydHkgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSBsaXN0IFRoZSBgTGlzdGVuZXJMaXN0YCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlQ2FsbGJhY2soXG4gICAgbGlzdDogTGlzdGVuZXJMaXN0LFxuKTogRXZlbnRUYXJnZXQuQ2FsbGJhY2tGdW5jdGlvbjxhbnksIGFueT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBsaXN0LmF0dHJDYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXZlbnQpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudCB9IGZyb20gXCIuL2V2ZW50XCJcbmltcG9ydCB7XG4gICAgZ2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZSxcbiAgICBzZXRFdmVudEF0dHJpYnV0ZVZhbHVlLFxufSBmcm9tIFwiLi9ldmVudC1hdHRyaWJ1dGUtaGFuZGxlclwiXG5pbXBvcnQgeyBFdmVudFRhcmdldCB9IGZyb20gXCIuL2V2ZW50LXRhcmdldFwiXG5cbi8qKlxuICogRGVmaW5lIGFuIGBFdmVudFRhcmdldGAgY2xhc3MgdGhhdCBoYXMgZXZlbnQgYXR0aWJ1dGVzLlxuICogQHBhcmFtIHR5cGVzIFRoZSB0eXBlcyB0byBkZWZpbmUgZXZlbnQgYXR0cmlidXRlcy5cbiAqIEBkZXByZWNhdGVkIFVzZSBgZ2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZWAvYHNldEV2ZW50QXR0cmlidXRlVmFsdWVgIHBhaXIgb24geW91ciBkZXJpdmVkIGNsYXNzIGluc3RlYWQgYmVjYXVzZSBvZiBzdGF0aWMgYW5hbHlzaXMgZnJpZW5kbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVDdXN0b21FdmVudFRhcmdldDxcbiAgICBURXZlbnRNYXAgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBFdmVudD4sXG4gICAgVE1vZGUgZXh0ZW5kcyBcInN0YW5kYXJkXCIgfCBcInN0cmljdFwiID0gXCJzdGFuZGFyZFwiXG4+KFxuICAgIC4uLnR5cGVzOiAoc3RyaW5nICYga2V5b2YgVEV2ZW50TWFwKVtdXG4pOiBkZWZpbmVDdXN0b21FdmVudFRhcmdldC5DdXN0b21FdmVudFRhcmdldENvbnN0cnVjdG9yPFRFdmVudE1hcCwgVE1vZGU+IHtcbiAgICBjbGFzcyBDdXN0b21FdmVudFRhcmdldCBleHRlbmRzIEV2ZW50VGFyZ2V0IHt9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZShDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUsIHR5cGVzW2ldKVxuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFRhcmdldCBhcyBhbnlcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBkZWZpbmVDdXN0b21FdmVudFRhcmdldCB7XG4gICAgLyoqXG4gICAgICogVGhlIGludGVyZmFjZSBvZiBDdXN0b21FdmVudFRhcmdldCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBleHBvcnQgdHlwZSBDdXN0b21FdmVudFRhcmdldENvbnN0cnVjdG9yPFxuICAgICAgICBURXZlbnRNYXAgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBFdmVudD4sXG4gICAgICAgIFRNb2RlIGV4dGVuZHMgXCJzdGFuZGFyZFwiIHwgXCJzdHJpY3RcIlxuICAgID4gPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBuZXcgKCk6IEN1c3RvbUV2ZW50VGFyZ2V0PFRFdmVudE1hcCwgVE1vZGU+XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm90b3R5cGUgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvdG90eXBlOiBDdXN0b21FdmVudFRhcmdldDxURXZlbnRNYXAsIFRNb2RlPlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcmZhY2Ugb2YgQ3VzdG9tRXZlbnRUYXJnZXQuXG4gICAgICovXG4gICAgZXhwb3J0IHR5cGUgQ3VzdG9tRXZlbnRUYXJnZXQ8XG4gICAgICAgIFRFdmVudE1hcCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIEV2ZW50PixcbiAgICAgICAgVE1vZGUgZXh0ZW5kcyBcInN0YW5kYXJkXCIgfCBcInN0cmljdFwiXG4gICAgPiA9IEV2ZW50VGFyZ2V0PFRFdmVudE1hcCwgVE1vZGU+ICZcbiAgICAgICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGUuRXZlbnRBdHRyaWJ1dGVzPGFueSwgVEV2ZW50TWFwPlxufVxuXG4vKipcbiAqIERlZmluZSBhbiBldmVudCBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBgRXZlbnRUYXJnZXRgIG9iamVjdCB0byBkZWZpbmUgYW4gZXZlbnQgYXR0cmlidXRlLlxuICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUgdG8gZGVmaW5lLlxuICogQHBhcmFtIF9ldmVudENsYXNzIFVudXNlZCwgYnV0IHRvIGluZmVyIGBFdmVudGAgY2xhc3MgdHlwZS5cbiAqIEBkZXByZWNhdGVkIFVzZSBgZ2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZWAvYHNldEV2ZW50QXR0cmlidXRlVmFsdWVgIHBhaXIgb24geW91ciBkZXJpdmVkIGNsYXNzIGluc3RlYWQgYmVjYXVzZSBvZiBzdGF0aWMgYW5hbHlzaXMgZnJpZW5kbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZTxcbiAgICBURXZlbnRUYXJnZXQgZXh0ZW5kcyBFdmVudFRhcmdldCxcbiAgICBURXZlbnRUeXBlIGV4dGVuZHMgc3RyaW5nLFxuICAgIFRFdmVudENvbnN0cnVjb3IgZXh0ZW5kcyB0eXBlb2YgRXZlbnRcbj4oXG4gICAgdGFyZ2V0OiBURXZlbnRUYXJnZXQsXG4gICAgdHlwZTogVEV2ZW50VHlwZSxcbiAgICBfZXZlbnRDbGFzcz86IFRFdmVudENvbnN0cnVjb3IsXG4pOiBhc3NlcnRzIHRhcmdldCBpcyBURXZlbnRUYXJnZXQgJlxuICAgIGRlZmluZUV2ZW50QXR0cmlidXRlLkV2ZW50QXR0cmlidXRlczxcbiAgICAgICAgVEV2ZW50VGFyZ2V0LFxuICAgICAgICBSZWNvcmQ8VEV2ZW50VHlwZSwgSW5zdGFuY2VUeXBlPFRFdmVudENvbnN0cnVjb3I+PlxuICAgID4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBvbiR7dHlwZX1gLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFdmVudEF0dHJpYnV0ZVZhbHVlKHRoaXMsIHR5cGUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgc2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZSh0aGlzLCB0eXBlLCB2YWx1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH0pXG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgZGVmaW5lRXZlbnRBdHRyaWJ1dGUge1xuICAgIC8qKlxuICAgICAqIERlZmluaXRpb24gb2YgZXZlbnQgYXR0cmlidXRlcy5cbiAgICAgKi9cbiAgICBleHBvcnQgdHlwZSBFdmVudEF0dHJpYnV0ZXM8XG4gICAgICAgIFRFdmVudFRhcmdldCBleHRlbmRzIEV2ZW50VGFyZ2V0PGFueSwgYW55PixcbiAgICAgICAgVEV2ZW50TWFwIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgRXZlbnQ+XG4gICAgPiA9IHtcbiAgICAgICAgW1AgaW4gc3RyaW5nICZcbiAgICAgICAgICAgIGtleW9mIFRFdmVudE1hcCBhcyBgb24ke1B9YF06IEV2ZW50VGFyZ2V0LkNhbGxiYWNrRnVuY3Rpb248XG4gICAgICAgICAgICBURXZlbnRUYXJnZXQsXG4gICAgICAgICAgICBURXZlbnRNYXBbUF1cbiAgICAgICAgPiB8IG51bGxcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7O0FBTUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdCQTtBQUVBOzs7O0FBSUE7QUFHQTtBQUtBO0FBQ0E7QUFTQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUVBO0FBR0E7OztBQUlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQ3JFQTs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2ZBO0FBRUE7Ozs7QUFJQTtBQUdBO0FBS0E7QUFDQTtBQTJCQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFNQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUlBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7QUM1RUE7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBT0E7QUFPQTtBQU9BO0FBQ0E7QUN2Q0E7QUFFQTs7Ozs7QUFLQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQU1BO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBeURBOzs7QUFHQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUM5YUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuRkE7Ozs7O0FBS0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBY0E7OztBQUdBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwS0E7Ozs7Ozs7OztBQVNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JIQTs7Ozs7OztBQU9BO0FBS0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7OztBQU9BO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFPQTtBQUtBOztBQUdBOztBQUdBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7Ozs7QUFJQTs7OztBQU9BO0FBQ0E7QUFDQTs7QUF3REE7QUFLQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQXdEQTtBQUtBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQWlCQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUdBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUdBOzs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFvSEE7OztBQUdBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTs7OztBQUlBOztBQVlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7OztBQU9BO0FBTUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTs7O0FDbmlCQTs7Ozs7QUFLQTs7QUFPQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBT0E7QUFJQTtBQUVBO0FBQ0E7QUFRQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1R0E7Ozs7O0FBS0E7QUFNQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQThCQTs7Ozs7OztBQU9BO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/event-target-shim/index.js\n");

/***/ }),

/***/ "./node_modules/naja/dist/Naja.esm.js":
/*!********************************************!*\
  !*** ./node_modules/naja/dist/Naja.esm.js ***!
  \********************************************/
/*! exports provided: default, HttpError, Naja */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpError\", function() { return HttpError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Naja\", function() { return Naja; });\n/* harmony import */ var event_target_shim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! event-target-shim */ \"./node_modules/event-target-shim/index.js\");\n/* harmony import */ var event_target_shim__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(event_target_shim__WEBPACK_IMPORTED_MODULE_0__);\n/*\n * Naja.js\n * 2.1.5\n *\n * by Jiří Pudil <https://jiripudil.cz>\n */\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n(function (factory) {\n  factory();\n}((function () {\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _getPrototypeOf(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _getPrototypeOf(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _possibleConstructorReturn(this, result);\n    };\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  var Emitter = /*#__PURE__*/function () {\n    function Emitter() {\n      _classCallCheck(this, Emitter);\n\n      Object.defineProperty(this, 'listeners', {\n        value: {},\n        writable: true,\n        configurable: true\n      });\n    }\n\n    _createClass(Emitter, [{\n      key: \"addEventListener\",\n      value: function addEventListener(type, callback, options) {\n        if (!(type in this.listeners)) {\n          this.listeners[type] = [];\n        }\n\n        this.listeners[type].push({\n          callback: callback,\n          options: options\n        });\n      }\n    }, {\n      key: \"removeEventListener\",\n      value: function removeEventListener(type, callback) {\n        if (!(type in this.listeners)) {\n          return;\n        }\n\n        var stack = this.listeners[type];\n\n        for (var i = 0, l = stack.length; i < l; i++) {\n          if (stack[i].callback === callback) {\n            stack.splice(i, 1);\n            return;\n          }\n        }\n      }\n    }, {\n      key: \"dispatchEvent\",\n      value: function dispatchEvent(event) {\n        if (!(event.type in this.listeners)) {\n          return;\n        }\n\n        var stack = this.listeners[event.type];\n        var stackToCall = stack.slice();\n\n        for (var i = 0, l = stackToCall.length; i < l; i++) {\n          var listener = stackToCall[i];\n\n          try {\n            listener.callback.call(this, event);\n          } catch (e) {\n            Promise.resolve().then(function () {\n              throw e;\n            });\n          }\n\n          if (listener.options && listener.options.once) {\n            this.removeEventListener(event.type, listener.callback);\n          }\n        }\n\n        return !event.defaultPrevented;\n      }\n    }]);\n\n    return Emitter;\n  }();\n\n  var AbortSignal = /*#__PURE__*/function (_Emitter) {\n    _inherits(AbortSignal, _Emitter);\n\n    var _super = _createSuper(AbortSignal);\n\n    function AbortSignal() {\n      var _this;\n\n      _classCallCheck(this, AbortSignal);\n\n      _this = _super.call(this); // Some versions of babel does not transpile super() correctly for IE <= 10, if the parent\n      // constructor has failed to run, then \"this.listeners\" will still be undefined and then we call\n      // the parent constructor directly instead as a workaround. For general details, see babel bug:\n      // https://github.com/babel/babel/issues/3041\n      // This hack was added as a fix for the issue described here:\n      // https://github.com/Financial-Times/polyfill-library/pull/59#issuecomment-477558042\n\n      if (!_this.listeners) {\n        Emitter.call(_assertThisInitialized(_this));\n      } // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and\n      // we want Object.keys(new AbortController().signal) to be [] for compat with the native impl\n\n\n      Object.defineProperty(_assertThisInitialized(_this), 'aborted', {\n        value: false,\n        writable: true,\n        configurable: true\n      });\n      Object.defineProperty(_assertThisInitialized(_this), 'onabort', {\n        value: null,\n        writable: true,\n        configurable: true\n      });\n      return _this;\n    }\n\n    _createClass(AbortSignal, [{\n      key: \"toString\",\n      value: function toString() {\n        return '[object AbortSignal]';\n      }\n    }, {\n      key: \"dispatchEvent\",\n      value: function dispatchEvent(event) {\n        if (event.type === 'abort') {\n          this.aborted = true;\n\n          if (typeof this.onabort === 'function') {\n            this.onabort.call(this, event);\n          }\n        }\n\n        _get(_getPrototypeOf(AbortSignal.prototype), \"dispatchEvent\", this).call(this, event);\n      }\n    }]);\n\n    return AbortSignal;\n  }(Emitter);\n  var AbortController = /*#__PURE__*/function () {\n    function AbortController() {\n      _classCallCheck(this, AbortController);\n\n      // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and\n      // we want Object.keys(new AbortController()) to be [] for compat with the native impl\n      Object.defineProperty(this, 'signal', {\n        value: new AbortSignal(),\n        writable: true,\n        configurable: true\n      });\n    }\n\n    _createClass(AbortController, [{\n      key: \"abort\",\n      value: function abort() {\n        var event;\n\n        try {\n          event = new Event('abort');\n        } catch (e) {\n          if (typeof document !== 'undefined') {\n            if (!document.createEvent) {\n              // For Internet Explorer 8:\n              event = document.createEventObject();\n              event.type = 'abort';\n            } else {\n              // For Internet Explorer 11:\n              event = document.createEvent('Event');\n              event.initEvent('abort', false, false);\n            }\n          } else {\n            // Fallback where document isn't available:\n            event = {\n              type: 'abort',\n              bubbles: false,\n              cancelable: false\n            };\n          }\n        }\n\n        this.signal.dispatchEvent(event);\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        return '[object AbortController]';\n      }\n    }]);\n\n    return AbortController;\n  }();\n\n  if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n    // These are necessary to make sure that we get correct output for:\n    // Object.prototype.toString.call(new AbortController())\n    AbortController.prototype[Symbol.toStringTag] = 'AbortController';\n    AbortSignal.prototype[Symbol.toStringTag] = 'AbortSignal';\n  }\n\n  function polyfillNeeded(self) {\n    if (self.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {\n      console.log('__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill');\n      return true;\n    } // Note that the \"unfetch\" minimal fetch polyfill defines fetch() without\n    // defining window.Request, and this polyfill need to work on top of unfetch\n    // so the below feature detection needs the !self.AbortController part.\n    // The Request.prototype check is also needed because Safari versions 11.1.2\n    // up to and including 12.1.x has a window.AbortController present but still\n    // does NOT correctly implement abortable fetch:\n    // https://bugs.webkit.org/show_bug.cgi?id=174980#c2\n\n\n    return typeof self.Request === 'function' && !self.Request.prototype.hasOwnProperty('signal') || !self.AbortController;\n  }\n\n  /**\n   * Note: the \"fetch.Request\" default value is available for fetch imported from\n   * the \"node-fetch\" package and not in browsers. This is OK since browsers\n   * will be importing umd-polyfill.js from that path \"self\" is passed the\n   * decorator so the default value will not be used (because browsers that define\n   * fetch also has Request). One quirky setup where self.fetch exists but\n   * self.Request does not is when the \"unfetch\" minimal fetch polyfill is used\n   * on top of IE11; for this case the browser will try to use the fetch.Request\n   * default value which in turn will be undefined but then then \"if (Request)\"\n   * will ensure that you get a patched fetch but still no Request (as expected).\n   * @param {fetch, Request = fetch.Request}\n   * @returns {fetch: abortableFetch, Request: AbortableRequest}\n   */\n\n  function abortableFetchDecorator(patchTargets) {\n    if ('function' === typeof patchTargets) {\n      patchTargets = {\n        fetch: patchTargets\n      };\n    }\n\n    var _patchTargets = patchTargets,\n        fetch = _patchTargets.fetch,\n        _patchTargets$Request = _patchTargets.Request,\n        NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request,\n        NativeAbortController = _patchTargets.AbortController,\n        _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL,\n        __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;\n\n    if (!polyfillNeeded({\n      fetch: fetch,\n      Request: NativeRequest,\n      AbortController: NativeAbortController,\n      __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL\n    })) {\n      return {\n        fetch: fetch,\n        Request: Request\n      };\n    }\n\n    var Request = NativeRequest; // Note that the \"unfetch\" minimal fetch polyfill defines fetch() without\n    // defining window.Request, and this polyfill need to work on top of unfetch\n    // hence we only patch it if it's available. Also we don't patch it if signal\n    // is already available on the Request prototype because in this case support\n    // is present and the patching below can cause a crash since it assigns to\n    // request.signal which is technically a read-only property. This latter error\n    // happens when you run the main5.js node-fetch example in the repo\n    // \"abortcontroller-polyfill-examples\". The exact error is:\n    //   request.signal = init.signal;\n    //   ^\n    // TypeError: Cannot set property signal of #<Request> which has only a getter\n\n    if (Request && !Request.prototype.hasOwnProperty('signal') || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {\n      Request = function Request(input, init) {\n        var signal;\n\n        if (init && init.signal) {\n          signal = init.signal; // Never pass init.signal to the native Request implementation when the polyfill has\n          // been installed because if we're running on top of a browser with a\n          // working native AbortController (i.e. the polyfill was installed due to\n          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our\n          // fake AbortSignal to the native fetch will trigger:\n          // TypeError: Failed to construct 'Request': member signal is not of type AbortSignal.\n\n          delete init.signal;\n        }\n\n        var request = new NativeRequest(input, init);\n\n        if (signal) {\n          Object.defineProperty(request, 'signal', {\n            writable: false,\n            enumerable: false,\n            configurable: true,\n            value: signal\n          });\n        }\n\n        return request;\n      };\n\n      Request.prototype = NativeRequest.prototype;\n    }\n\n    var realFetch = fetch;\n\n    var abortableFetch = function abortableFetch(input, init) {\n      var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;\n\n      if (signal) {\n        var abortError;\n\n        try {\n          abortError = new DOMException('Aborted', 'AbortError');\n        } catch (err) {\n          // IE 11 does not support calling the DOMException constructor, use a\n          // regular error object on it instead.\n          abortError = new Error('Aborted');\n          abortError.name = 'AbortError';\n        } // Return early if already aborted, thus avoiding making an HTTP request\n\n\n        if (signal.aborted) {\n          return Promise.reject(abortError);\n        } // Turn an event into a promise, reject it once `abort` is dispatched\n\n\n        var cancellation = new Promise(function (_, reject) {\n          signal.addEventListener('abort', function () {\n            return reject(abortError);\n          }, {\n            once: true\n          });\n        });\n\n        if (init && init.signal) {\n          // Never pass .signal to the native implementation when the polyfill has\n          // been installed because if we're running on top of a browser with a\n          // working native AbortController (i.e. the polyfill was installed due to\n          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our\n          // fake AbortSignal to the native fetch will trigger:\n          // TypeError: Failed to execute 'fetch' on 'Window': member signal is not of type AbortSignal.\n          delete init.signal;\n        } // Return the fastest promise (don't need to wait for request to finish)\n\n\n        return Promise.race([cancellation, realFetch(input, init)]);\n      }\n\n      return realFetch(input, init);\n    };\n\n    return {\n      fetch: abortableFetch,\n      Request: Request\n    };\n  }\n\n  (function (self) {\n\n    if (!polyfillNeeded(self)) {\n      return;\n    }\n\n    if (!self.fetch) {\n      console.warn('fetch() is not available, cannot install abortcontroller-polyfill');\n      return;\n    }\n\n    var _abortableFetch = abortableFetchDecorator(self),\n        fetch = _abortableFetch.fetch,\n        Request = _abortableFetch.Request;\n\n    self.fetch = fetch;\n    self.Request = Request;\n    Object.defineProperty(self, 'AbortController', {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: AbortController\n    });\n    Object.defineProperty(self, 'AbortSignal', {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: AbortSignal\n    });\n  })(typeof self !== 'undefined' ? self : commonjsGlobal);\n\n})));\n\n// https://bugs.webkit.org/show_bug.cgi?id=174980\n\ntry {\n  new window.EventTarget();\n} catch (error) {\n  window.EventTarget = event_target_shim__WEBPACK_IMPORTED_MODULE_0__[\"EventTarget\"];\n}\n\nclass AssertionError extends Error {\n}\nconst assert = (condition, description) => {\n    if (!condition) {\n        const message = `Assertion failed${description !== undefined ? `: ${description}` : '.'}`;\n        throw new AssertionError(message);\n    }\n};\n\nclass UIHandler extends EventTarget {\n    constructor(naja) {\n        super();\n        this.naja = naja;\n        this.selector = '.ajax';\n        this.allowedOrigins = [window.location.origin];\n        this.handler = this.handleUI.bind(this);\n        naja.addEventListener('init', this.initialize.bind(this));\n    }\n    initialize() {\n        this.bindUI(window.document.body);\n        this.naja.snippetHandler.addEventListener('afterUpdate', (event) => {\n            const { snippet } = event.detail;\n            this.bindUI(snippet);\n        });\n    }\n    bindUI(element) {\n        const selectors = [\n            `a${this.selector}`,\n            `input[type=\"submit\"]${this.selector}`,\n            `input[type=\"image\"]${this.selector}`,\n            `button[type=\"submit\"]${this.selector}`,\n            `form${this.selector} input[type=\"submit\"]`,\n            `form${this.selector} input[type=\"image\"]`,\n            `form${this.selector} button[type=\"submit\"]`,\n        ].join(', ');\n        const bindElement = (element) => {\n            element.removeEventListener('click', this.handler);\n            element.addEventListener('click', this.handler);\n        };\n        const elements = element.querySelectorAll(selectors);\n        for (let i = 0; i < elements.length; i++) {\n            bindElement(elements.item(i));\n        }\n        if (element.matches(selectors)) {\n            bindElement(element);\n        }\n        const bindForm = (form) => {\n            form.removeEventListener('submit', this.handler);\n            form.addEventListener('submit', this.handler);\n        };\n        if (element.matches(`form${this.selector}`)) {\n            bindForm(element);\n        }\n        const forms = element.querySelectorAll(`form${this.selector}`);\n        for (let i = 0; i < forms.length; i++) {\n            bindForm(forms.item(i));\n        }\n    }\n    handleUI(event) {\n        const mouseEvent = event;\n        if (mouseEvent.altKey || mouseEvent.ctrlKey || mouseEvent.shiftKey || mouseEvent.metaKey || mouseEvent.button) {\n            return;\n        }\n        const element = event.currentTarget;\n        const options = {};\n        const ignoreErrors = () => {\n            // don't reject the promise in case of an error as developers have no way of handling the rejection\n            // in this situation; errors should be handled in `naja.addEventListener('error', errorHandler)`\n        };\n        if (event.type === 'submit') {\n            this.submitForm(element, options, event).catch(ignoreErrors);\n        }\n        else if (event.type === 'click') {\n            this.clickElement(element, options, mouseEvent).catch(ignoreErrors);\n        }\n    }\n    async clickElement(element, options = {}, event) {\n        var _a, _b, _c, _d, _e, _f;\n        let method = 'GET', url = '', data;\n        if (!this.dispatchEvent(new CustomEvent('interaction', { cancelable: true, detail: { element, originalEvent: event, options } }))) {\n            event === null || event === void 0 ? void 0 : event.preventDefault();\n            return {};\n        }\n        if (element.tagName === 'A') {\n            assert(element instanceof HTMLAnchorElement);\n            method = 'GET';\n            url = element.href;\n            data = null;\n        }\n        else if (element.tagName === 'INPUT' || element.tagName === 'BUTTON') {\n            assert(element instanceof HTMLInputElement || element instanceof HTMLButtonElement);\n            const { form } = element;\n            // eslint-disable-next-line no-nested-ternary,no-extra-parens\n            method = (_d = (_b = (_a = element.getAttribute('formmethod')) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : (_c = form === null || form === void 0 ? void 0 : form.getAttribute('method')) === null || _c === void 0 ? void 0 : _c.toUpperCase()) !== null && _d !== void 0 ? _d : 'GET';\n            url = (_f = (_e = element.getAttribute('formaction')) !== null && _e !== void 0 ? _e : form === null || form === void 0 ? void 0 : form.getAttribute('action')) !== null && _f !== void 0 ? _f : window.location.pathname + window.location.search;\n            data = new FormData(form !== null && form !== void 0 ? form : undefined);\n            if (element.type === 'submit' || element.tagName === 'BUTTON') {\n                data.append(element.name, element.value || '');\n            }\n            else if (element.type === 'image') {\n                const coords = element.getBoundingClientRect();\n                data.append(`${element.name}.x`, Math.max(0, Math.floor(event !== undefined ? event.pageX - coords.left : 0)));\n                data.append(`${element.name}.y`, Math.max(0, Math.floor(event !== undefined ? event.pageY - coords.top : 0)));\n            }\n        }\n        if (!this.isUrlAllowed(url)) {\n            throw new Error(`Cannot dispatch async request, URL is not allowed: ${url}`);\n        }\n        event === null || event === void 0 ? void 0 : event.preventDefault();\n        return this.naja.makeRequest(method, url, data, options);\n    }\n    async submitForm(form, options = {}, event) {\n        var _a, _b, _c;\n        if (!this.dispatchEvent(new CustomEvent('interaction', { cancelable: true, detail: { element: form, originalEvent: event, options } }))) {\n            event === null || event === void 0 ? void 0 : event.preventDefault();\n            return {};\n        }\n        const method = (_b = (_a = form.getAttribute('method')) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : 'GET';\n        const url = (_c = form.getAttribute('action')) !== null && _c !== void 0 ? _c : window.location.pathname + window.location.search;\n        const data = new FormData(form);\n        if (!this.isUrlAllowed(url)) {\n            throw new Error(`Cannot dispatch async request, URL is not allowed: ${url}`);\n        }\n        event === null || event === void 0 ? void 0 : event.preventDefault();\n        return this.naja.makeRequest(method, url, data, options);\n    }\n    isUrlAllowed(url) {\n        const urlObject = new URL(url, location.href);\n        // ignore non-URL URIs (javascript:, data:, mailto:, ...)\n        if (urlObject.origin === 'null') {\n            return false;\n        }\n        return this.allowedOrigins.includes(urlObject.origin);\n    }\n}\n\nclass FormsHandler {\n    constructor(naja) {\n        this.naja = naja;\n        naja.addEventListener('init', this.initialize.bind(this));\n        naja.uiHandler.addEventListener('interaction', this.processForm.bind(this));\n    }\n    initialize() {\n        this.initForms(window.document.body);\n        this.naja.snippetHandler.addEventListener('afterUpdate', (event) => {\n            const { snippet } = event.detail;\n            this.initForms(snippet);\n        });\n    }\n    initForms(element) {\n        const netteForms = this.netteForms || window.Nette;\n        if (netteForms) {\n            if (element.tagName === 'form') {\n                netteForms.initForm(element);\n            }\n            const forms = element.querySelectorAll('form');\n            for (let i = 0; i < forms.length; i++) {\n                netteForms.initForm(forms.item(i));\n            }\n        }\n    }\n    processForm(event) {\n        const { element, originalEvent } = event.detail;\n        const inputElement = element;\n        if (inputElement.form !== undefined && inputElement.form !== null) {\n            inputElement.form['nette-submittedBy'] = element;\n        }\n        const netteForms = this.netteForms || window.Nette;\n        if ((element.tagName === 'FORM' || element.form) && netteForms && !netteForms.validateForm(element)) {\n            if (originalEvent) {\n                originalEvent.stopImmediatePropagation();\n                originalEvent.preventDefault();\n            }\n            event.preventDefault();\n        }\n    }\n}\n\nclass RedirectHandler extends EventTarget {\n    constructor(naja) {\n        super();\n        this.naja = naja;\n        naja.uiHandler.addEventListener('interaction', (event) => {\n            var _a, _b, _c;\n            const { element, options } = event.detail;\n            if (!element) {\n                return;\n            }\n            if (element.hasAttribute('data-naja-force-redirect') || ((_a = element.form) === null || _a === void 0 ? void 0 : _a.hasAttribute('data-naja-force-redirect'))) {\n                const value = (_b = element.getAttribute('data-naja-force-redirect')) !== null && _b !== void 0 ? _b : (_c = element.form) === null || _c === void 0 ? void 0 : _c.getAttribute('data-naja-force-redirect');\n                options.forceRedirect = value !== 'off';\n            }\n        });\n        naja.addEventListener('success', (event) => {\n            var _a;\n            const { payload, options } = event.detail;\n            if (payload.redirect) {\n                this.makeRedirect(payload.redirect, (_a = options.forceRedirect) !== null && _a !== void 0 ? _a : false, options);\n                event.stopImmediatePropagation();\n            }\n        });\n        this.locationAdapter = {\n            assign: (url) => window.location.assign(url),\n        };\n    }\n    makeRedirect(url, force, options = {}) {\n        if (url instanceof URL) {\n            url = url.href;\n        }\n        let isHardRedirect = force || !this.naja.uiHandler.isUrlAllowed(url);\n        const canRedirect = this.dispatchEvent(new CustomEvent('redirect', {\n            cancelable: true,\n            detail: {\n                url,\n                isHardRedirect,\n                setHardRedirect(value) {\n                    isHardRedirect = !!value;\n                },\n                options,\n            },\n        }));\n        if (!canRedirect) {\n            return;\n        }\n        if (isHardRedirect) {\n            this.locationAdapter.assign(url);\n        }\n        else {\n            this.naja.makeRequest('GET', url, null, options);\n        }\n    }\n}\n\nclass SnippetHandler extends EventTarget {\n    constructor(naja) {\n        super();\n        this.naja = naja;\n        this.op = {\n            replace: (snippet, content) => {\n                snippet.innerHTML = content;\n            },\n            prepend: (snippet, content) => snippet.insertAdjacentHTML('afterbegin', content),\n            append: (snippet, content) => snippet.insertAdjacentHTML('beforeend', content),\n        };\n        naja.addEventListener('success', (event) => {\n            const { options, payload } = event.detail;\n            if (payload.snippets) {\n                this.updateSnippets(payload.snippets, false, options);\n            }\n        });\n    }\n    updateSnippets(snippets, fromCache = false, options = {}) {\n        Object.keys(snippets).forEach((id) => {\n            const snippet = document.getElementById(id);\n            if (snippet) {\n                this.updateSnippet(snippet, snippets[id], fromCache, options);\n            }\n        });\n    }\n    updateSnippet(snippet, content, fromCache, options) {\n        let operation = this.op.replace;\n        if ((snippet.hasAttribute('data-naja-snippet-prepend') || snippet.hasAttribute('data-ajax-prepend')) && !fromCache) {\n            operation = this.op.prepend;\n        }\n        else if ((snippet.hasAttribute('data-naja-snippet-append') || snippet.hasAttribute('data-ajax-append')) && !fromCache) {\n            operation = this.op.append;\n        }\n        const canUpdate = this.dispatchEvent(new CustomEvent('beforeUpdate', {\n            cancelable: true,\n            detail: {\n                snippet,\n                content,\n                fromCache,\n                operation,\n                changeOperation(value) {\n                    operation = value;\n                },\n                options,\n            },\n        }));\n        if (!canUpdate) {\n            return;\n        }\n        if (snippet.tagName.toLowerCase() === 'title') {\n            document.title = content;\n        }\n        else {\n            operation(snippet, content);\n        }\n        this.dispatchEvent(new CustomEvent('afterUpdate', {\n            cancelable: true,\n            detail: {\n                snippet,\n                content,\n                fromCache,\n                operation,\n                options,\n            },\n        }));\n    }\n}\n\nclass HistoryHandler {\n    constructor(naja) {\n        this.naja = naja;\n        this.href = null;\n        this.popStateHandler = this.handlePopState.bind(this);\n        this.uiCache = true;\n        naja.addEventListener('init', this.initialize.bind(this));\n        naja.addEventListener('before', this.saveUrl.bind(this));\n        naja.addEventListener('success', this.pushNewState.bind(this));\n        naja.uiHandler.addEventListener('interaction', this.configureMode.bind(this));\n        this.historyAdapter = {\n            replaceState: (data, title, url) => window.history.replaceState(data, title, url),\n            pushState: (data, title, url) => window.history.pushState(data, title, url),\n        };\n    }\n    initialize(event) {\n        const { defaultOptions } = event.detail;\n        if ('historyUiCache' in defaultOptions && defaultOptions.historyUiCache !== undefined) {\n            this.uiCache = defaultOptions.historyUiCache;\n        }\n        window.addEventListener('popstate', this.popStateHandler);\n        this.historyAdapter.replaceState(this.buildState(window.location.href, this.uiCache), window.document.title, window.location.href);\n    }\n    handlePopState(e) {\n        if (!e.state) {\n            return;\n        }\n        if (e.state.ui) {\n            this.handleSnippets(e.state.ui);\n            this.handleTitle(e.state.title);\n        }\n        else if (e.state.ui === false) {\n            this.naja.makeRequest('GET', e.state.href, null, {\n                history: false,\n                historyUiCache: false,\n            });\n        }\n    }\n    saveUrl(event) {\n        const { url } = event.detail;\n        this.href = url;\n    }\n    configureMode(event) {\n        var _a, _b, _c, _d, _e, _f;\n        const { element, options } = event.detail;\n        // propagate mode to options\n        if (!element) {\n            return;\n        }\n        if (element.hasAttribute('data-naja-history') || ((_a = element.form) === null || _a === void 0 ? void 0 : _a.hasAttribute('data-naja-history'))) {\n            const value = (_b = element.getAttribute('data-naja-history')) !== null && _b !== void 0 ? _b : (_c = element.form) === null || _c === void 0 ? void 0 : _c.getAttribute('data-naja-history');\n            options.history = HistoryHandler.normalizeMode(value);\n        }\n        if (element.hasAttribute('data-naja-history-cache') || ((_d = element.form) === null || _d === void 0 ? void 0 : _d.hasAttribute('data-naja-history-nocache'))) {\n            const value = (_e = element.getAttribute('data-naja-history-cache')) !== null && _e !== void 0 ? _e : (_f = element.form) === null || _f === void 0 ? void 0 : _f.getAttribute('data-naja-history-cache');\n            options.historyUiCache = value !== 'off';\n        }\n    }\n    static normalizeMode(mode) {\n        if (mode === 'off' || mode === false) {\n            return false;\n        }\n        else if (mode === 'replace') {\n            return 'replace';\n        }\n        return true;\n    }\n    pushNewState(event) {\n        const { payload, options } = event.detail;\n        const mode = HistoryHandler.normalizeMode(options.history);\n        if (mode === false) {\n            return;\n        }\n        if (payload.postGet && payload.url) {\n            this.href = payload.url;\n        }\n        const method = mode === 'replace' ? 'replaceState' : 'pushState';\n        const uiCache = options.historyUiCache === true || (options.historyUiCache !== false && this.uiCache); // eslint-disable-line no-extra-parens\n        this.historyAdapter[method](this.buildState(this.href, uiCache), window.document.title, this.href);\n        this.href = null;\n    }\n    buildState(href, uiCache) {\n        const state = {\n            href,\n        };\n        if (uiCache) {\n            state.title = window.document.title;\n            state.ui = this.findSnippets();\n        }\n        else {\n            state.ui = false;\n        }\n        return state;\n    }\n    findSnippets() {\n        const result = {};\n        const snippets = window.document.querySelectorAll('[id^=\"snippet-\"]');\n        for (let i = 0; i < snippets.length; i++) {\n            const snippet = snippets.item(i);\n            if (!snippet.hasAttribute('data-naja-history-nocache') && !snippet.hasAttribute('data-history-nocache')) {\n                result[snippet.id] = snippet.innerHTML;\n            }\n        }\n        return result;\n    }\n    handleSnippets(snippets) {\n        this.naja.snippetHandler.updateSnippets(snippets, true);\n        this.naja.scriptLoader.loadScripts(snippets);\n    }\n    handleTitle(title) {\n        window.document.title = title;\n    }\n}\n\nclass ScriptLoader {\n    constructor(naja) {\n        naja.addEventListener('success', (event) => {\n            const { payload } = event.detail;\n            if (payload.snippets) {\n                this.loadScripts(payload.snippets);\n            }\n        });\n    }\n    loadScripts(snippets) {\n        Object.keys(snippets).forEach((id) => {\n            const content = snippets[id];\n            if (!/<script/i.test(content)) {\n                return;\n            }\n            const el = window.document.createElement('div');\n            el.innerHTML = content;\n            const scripts = el.querySelectorAll('script');\n            for (let i = 0; i < scripts.length; i++) {\n                const script = scripts.item(i);\n                const scriptEl = window.document.createElement('script');\n                scriptEl.innerHTML = script.innerHTML;\n                if (script.hasAttributes()) {\n                    const attrs = script.attributes;\n                    for (let j = 0; j < attrs.length; j++) {\n                        const attrName = attrs[j].name;\n                        scriptEl.setAttribute(attrName, attrs[j].value);\n                    }\n                }\n                window.document.head.appendChild(scriptEl)\n                    .parentNode.removeChild(scriptEl);\n            }\n        });\n    }\n}\n\nclass Naja extends EventTarget {\n    constructor(uiHandler, redirectHandler, snippetHandler, formsHandler, historyHandler, scriptLoader) {\n        super();\n        this.VERSION = 2;\n        this.initialized = false;\n        this.extensions = [];\n        this.defaultOptions = {};\n        this.uiHandler = uiHandler ? new uiHandler(this) : new UIHandler(this);\n        this.redirectHandler = redirectHandler ? new redirectHandler(this) : new RedirectHandler(this);\n        this.snippetHandler = snippetHandler ? new snippetHandler(this) : new SnippetHandler(this);\n        this.formsHandler = formsHandler ? new formsHandler(this) : new FormsHandler(this);\n        this.historyHandler = historyHandler ? new historyHandler(this) : new HistoryHandler(this);\n        this.scriptLoader = scriptLoader ? new scriptLoader(this) : new ScriptLoader(this);\n    }\n    registerExtension(extension) {\n        if (this.initialized) {\n            extension.initialize(this);\n        }\n        this.extensions.push(extension);\n    }\n    initialize(defaultOptions = {}) {\n        if (this.initialized) {\n            throw new Error('Cannot initialize Naja, it is already initialized.');\n        }\n        this.defaultOptions = defaultOptions;\n        this.extensions.forEach((extension) => extension.initialize(this));\n        this.dispatchEvent(new CustomEvent('init', { detail: { defaultOptions } }));\n        this.initialized = true;\n    }\n    async makeRequest(method, url, data = null, options = {}) {\n        // normalize url to instanceof URL\n        if (typeof url === 'string') {\n            url = new URL(url, location.href);\n        }\n        options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), options), { fetch: Object.assign(Object.assign({}, this.defaultOptions.fetch || {}), options.fetch || {}) });\n        const headers = new Headers(options.fetch.headers || {});\n        const body = this.transformData(url, method, data);\n        const abortController = new AbortController();\n        const request = new Request(url.toString(), Object.assign(Object.assign({ credentials: 'same-origin' }, options.fetch), { method,\n            headers,\n            body, signal: abortController.signal }));\n        // impersonate XHR so that Nette can detect isAjax()\n        request.headers.set('X-Requested-With', 'XMLHttpRequest');\n        if (!this.dispatchEvent(new CustomEvent('before', { cancelable: true, detail: { request, method, url: url.toString(), data, options } }))) {\n            return {};\n        }\n        const promise = window.fetch(request);\n        this.dispatchEvent(new CustomEvent('start', { detail: { request, promise, abortController, options } }));\n        let response, payload;\n        try {\n            response = await promise;\n            if (!response.ok) {\n                throw new HttpError(response);\n            }\n            payload = await response.json();\n        }\n        catch (error) {\n            if (error.name === 'AbortError') {\n                this.dispatchEvent(new CustomEvent('abort', { detail: { request, error, options } }));\n                this.dispatchEvent(new CustomEvent('complete', { detail: { request, response, payload: undefined, error, options } }));\n                return {};\n            }\n            this.dispatchEvent(new CustomEvent('error', { detail: { request, response, error, options } }));\n            this.dispatchEvent(new CustomEvent('complete', { detail: { request, response, payload: undefined, error, options } }));\n            throw error;\n        }\n        this.dispatchEvent(new CustomEvent('success', { detail: { request, response, payload, options } }));\n        this.dispatchEvent(new CustomEvent('complete', { detail: { request, response, payload, error: undefined, options } }));\n        return payload;\n    }\n    appendToQueryString(searchParams, key, value) {\n        if (value === null || value === undefined) {\n            return;\n        }\n        if (Array.isArray(value)) {\n            let index = 0;\n            for (const subvalue of value) {\n                this.appendToQueryString(searchParams, `${key}[${index++}]`, subvalue);\n            }\n        }\n        else if (Object.getPrototypeOf(value) === Object.prototype) {\n            for (const [subkey, subvalue] of Object.entries(value)) {\n                this.appendToQueryString(searchParams, `${key}[${subkey}]`, subvalue);\n            }\n        }\n        else {\n            searchParams.append(key, String(value));\n        }\n    }\n    transformData(url, method, data) {\n        const isGet = ['GET', 'HEAD'].includes(method.toUpperCase());\n        // sending a form via GET -> serialize FormData into URL and return empty request body\n        if (isGet && data instanceof FormData) {\n            for (const [key, value] of data) {\n                if (value !== null && value !== undefined) {\n                    url.searchParams.append(key, String(value));\n                }\n            }\n            return null;\n        }\n        // sending a POJO -> serialize it recursively into URLSearchParams\n        const isDataPojo = data !== null && Object.getPrototypeOf(data) === Object.prototype;\n        if (isDataPojo) {\n            // for GET requests, append values to URL and return empty request body\n            // otherwise build `new URLSearchParams()` to act as the request body\n            const transformedData = isGet ? url.searchParams : new URLSearchParams();\n            for (const [key, value] of Object.entries(data)) {\n                this.appendToQueryString(transformedData, key, value);\n            }\n            return isGet\n                ? null\n                : transformedData;\n        }\n        return data;\n    }\n}\nclass HttpError extends Error {\n    constructor(response) {\n        const message = `HTTP ${response.status}: ${response.statusText}`;\n        super(message);\n        this.name = this.constructor.name;\n        this.stack = new Error(message).stack;\n        this.response = response;\n    }\n}\n\nclass AbortExtension {\n    constructor() {\n        this.abortable = true;\n        this.abortController = null;\n    }\n    initialize(naja) {\n        naja.uiHandler.addEventListener('interaction', this.checkAbortable.bind(this));\n        naja.addEventListener('init', this.onInitialize.bind(this));\n        naja.addEventListener('before', this.checkAbortable.bind(this));\n        naja.addEventListener('start', this.saveAbortController.bind(this));\n        naja.addEventListener('complete', this.clearAbortController.bind(this));\n    }\n    onInitialize() {\n        document.addEventListener('keydown', (event) => {\n            if (this.abortController !== null\n                && event.key === 'Escape'\n                && !(event.ctrlKey || event.shiftKey || event.altKey || event.metaKey)\n                && this.abortable) {\n                this.abortController.abort();\n                this.abortController = null;\n            }\n        });\n    }\n    checkAbortable(event) {\n        var _a, _b;\n        const { options } = event.detail;\n        this.abortable = 'element' in event.detail\n            ? ((_a = event.detail.element.getAttribute('data-naja-abort')) !== null && _a !== void 0 ? _a : (_b = event.detail.element.form) === null || _b === void 0 ? void 0 : _b.getAttribute('data-naja-abort')) !== 'off' // eslint-disable-line no-extra-parens\n            : options.abort !== false;\n        // propagate to options if called in interaction event\n        options.abort = this.abortable;\n    }\n    saveAbortController(event) {\n        const { abortController } = event.detail;\n        this.abortController = abortController;\n    }\n    clearAbortController() {\n        this.abortController = null;\n        this.abortable = true;\n    }\n}\n\nclass UniqueExtension {\n    constructor() {\n        this.abortControllers = new Map();\n    }\n    initialize(naja) {\n        naja.uiHandler.addEventListener('interaction', this.checkUniqueness.bind(this));\n        naja.addEventListener('start', this.abortPreviousRequest.bind(this));\n        naja.addEventListener('complete', this.clearRequest.bind(this));\n    }\n    checkUniqueness(event) {\n        var _a, _b;\n        const { element, options } = event.detail;\n        const unique = (_a = element.getAttribute('data-naja-unique')) !== null && _a !== void 0 ? _a : (_b = element.form) === null || _b === void 0 ? void 0 : _b.getAttribute('data-naja-unique');\n        options.unique = unique === 'off' ? false : unique !== null && unique !== void 0 ? unique : 'default';\n    }\n    abortPreviousRequest(event) {\n        var _a, _b, _c;\n        const { abortController, options } = event.detail;\n        if (options.unique !== false) {\n            (_b = this.abortControllers.get((_a = options.unique) !== null && _a !== void 0 ? _a : 'default')) === null || _b === void 0 ? void 0 : _b.abort();\n            this.abortControllers.set((_c = options.unique) !== null && _c !== void 0 ? _c : 'default', abortController);\n        }\n    }\n    clearRequest(event) {\n        var _a;\n        const { request, options } = event.detail;\n        if (!request.signal.aborted && options.unique !== false) {\n            this.abortControllers.delete((_a = options.unique) !== null && _a !== void 0 ? _a : 'default');\n        }\n    }\n}\n\nconst naja = new Naja();\nnaja.registerExtension(new AbortExtension());\nnaja.registerExtension(new UniqueExtension());\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (naja);\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmFqYS9kaXN0L05hamEuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9wb2x5ZmlsbC1wYXRjaC1mZXRjaC5qcz8yODQxIiwid2VicGFjazovLy8uLi9zcmMvcG9seWZpbGxzLmpzP2MyNmMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy91dGlscy50cz83ZjMzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9VSUhhbmRsZXIudHM/YWJjNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvRm9ybXNIYW5kbGVyLnRzPzQ3M2IiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL1JlZGlyZWN0SGFuZGxlci50cz9kZjFjIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9TbmlwcGV0SGFuZGxlci50cz84NjAzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9IaXN0b3J5SGFuZGxlci50cz9iMzU1Iiwid2VicGFjazovLy8uLi9zcmMvY29yZS9TY3JpcHRMb2FkZXIudHM/ODk0NSIsIndlYnBhY2s6Ly8vLi4vc3JjL05hamEudHM/Y2ExYiIsIndlYnBhY2s6Ly8vLi4vc3JjL2V4dGVuc2lvbnMvQWJvcnRFeHRlbnNpb24udHM/MTQ3MSIsIndlYnBhY2s6Ly8vLi4vc3JjL2V4dGVuc2lvbnMvVW5pcXVlRXh0ZW5zaW9uLnRzPzFmMzIiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pbmRleC5lc20udHM/MTRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgpO1xufSgoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG4gIH1cblxuICB2YXIgRW1pdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyKTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdsaXN0ZW5lcnMnLCB7XG4gICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIsIFt7XG4gICAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbiB0aGlzLmxpc3RlbmVycykpIHtcbiAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7XG4gICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFjay5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoc3RhY2tbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzdGFjay5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRpc3BhdGNoRXZlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghKGV2ZW50LnR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5saXN0ZW5lcnNbZXZlbnQudHlwZV07XG4gICAgICAgIHZhciBzdGFja1RvQ2FsbCA9IHN0YWNrLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFja1RvQ2FsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBzdGFja1RvQ2FsbFtpXTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaXN0ZW5lci5vcHRpb25zICYmIGxpc3RlbmVyLm9wdGlvbnMub25jZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEVtaXR0ZXI7XG4gIH0oKTtcblxuICB2YXIgQWJvcnRTaWduYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKEFib3J0U2lnbmFsLCBfRW1pdHRlcik7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEFib3J0U2lnbmFsKTtcblxuICAgIGZ1bmN0aW9uIEFib3J0U2lnbmFsKCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRTaWduYWwpO1xuXG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpOyAvLyBTb21lIHZlcnNpb25zIG9mIGJhYmVsIGRvZXMgbm90IHRyYW5zcGlsZSBzdXBlcigpIGNvcnJlY3RseSBmb3IgSUUgPD0gMTAsIGlmIHRoZSBwYXJlbnRcbiAgICAgIC8vIGNvbnN0cnVjdG9yIGhhcyBmYWlsZWQgdG8gcnVuLCB0aGVuIFwidGhpcy5saXN0ZW5lcnNcIiB3aWxsIHN0aWxsIGJlIHVuZGVmaW5lZCBhbmQgdGhlbiB3ZSBjYWxsXG4gICAgICAvLyB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIGRpcmVjdGx5IGluc3RlYWQgYXMgYSB3b3JrYXJvdW5kLiBGb3IgZ2VuZXJhbCBkZXRhaWxzLCBzZWUgYmFiZWwgYnVnOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2lzc3Vlcy8zMDQxXG4gICAgICAvLyBUaGlzIGhhY2sgd2FzIGFkZGVkIGFzIGEgZml4IGZvciB0aGUgaXNzdWUgZGVzY3JpYmVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLWxpYnJhcnkvcHVsbC81OSNpc3N1ZWNvbW1lbnQtNDc3NTU4MDQyXG5cbiAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgIEVtaXR0ZXIuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICB9IC8vIENvbXBhcmVkIHRvIGFzc2lnbm1lbnQsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBtYWtlcyBwcm9wZXJ0aWVzIG5vbi1lbnVtZXJhYmxlIGJ5IGRlZmF1bHQgYW5kXG4gICAgICAvLyB3ZSB3YW50IE9iamVjdC5rZXlzKG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwpIHRvIGJlIFtdIGZvciBjb21wYXQgd2l0aCB0aGUgbmF0aXZlIGltcGxcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICdhYm9ydGVkJywge1xuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAnb25hYm9ydCcsIHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBYm9ydFNpZ25hbCwgW3tcbiAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ1tvYmplY3QgQWJvcnRTaWduYWxdJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGlzcGF0Y2hFdmVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdhYm9ydCcpIHtcbiAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uYWJvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub25hYm9ydC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihBYm9ydFNpZ25hbC5wcm90b3R5cGUpLCBcImRpc3BhdGNoRXZlbnRcIiwgdGhpcykuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFib3J0U2lnbmFsO1xuICB9KEVtaXR0ZXIpO1xuICB2YXIgQWJvcnRDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYm9ydENvbnRyb2xsZXIoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRDb250cm9sbGVyKTtcblxuICAgICAgLy8gQ29tcGFyZWQgdG8gYXNzaWdubWVudCwgT2JqZWN0LmRlZmluZVByb3BlcnR5IG1ha2VzIHByb3BlcnRpZXMgbm9uLWVudW1lcmFibGUgYnkgZGVmYXVsdCBhbmRcbiAgICAgIC8vIHdlIHdhbnQgT2JqZWN0LmtleXMobmV3IEFib3J0Q29udHJvbGxlcigpKSB0byBiZSBbXSBmb3IgY29tcGF0IHdpdGggdGhlIG5hdGl2ZSBpbXBsXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NpZ25hbCcsIHtcbiAgICAgICAgdmFsdWU6IG5ldyBBYm9ydFNpZ25hbCgpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQWJvcnRDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcImFib3J0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIHZhciBldmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50KCdhYm9ydCcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgLy8gRm9yIEludGVybmV0IEV4cGxvcmVyIDg6XG4gICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9ICdhYm9ydCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTE6XG4gICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgnYWJvcnQnLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB3aGVyZSBkb2N1bWVudCBpc24ndCBhdmFpbGFibGU6XG4gICAgICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Fib3J0JyxcbiAgICAgICAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ1tvYmplY3QgQWJvcnRDb250cm9sbGVyXSc7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFib3J0Q29udHJvbGxlcjtcbiAgfSgpO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAvLyBUaGVzZSBhcmUgbmVjZXNzYXJ5IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGdldCBjb3JyZWN0IG91dHB1dCBmb3I6XG4gICAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBBYm9ydENvbnRyb2xsZXIoKSlcbiAgICBBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnQWJvcnRDb250cm9sbGVyJztcbiAgICBBYm9ydFNpZ25hbC5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdBYm9ydFNpZ25hbCc7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5ZmlsbE5lZWRlZChzZWxmKSB7XG4gICAgaWYgKHNlbGYuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkge1xuICAgICAgY29uc29sZS5sb2coJ19fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEw9dHJ1ZSBpcyBzZXQsIHdpbGwgZm9yY2UgaW5zdGFsbCBwb2x5ZmlsbCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3RlIHRoYXQgdGhlIFwidW5mZXRjaFwiIG1pbmltYWwgZmV0Y2ggcG9seWZpbGwgZGVmaW5lcyBmZXRjaCgpIHdpdGhvdXRcbiAgICAvLyBkZWZpbmluZyB3aW5kb3cuUmVxdWVzdCwgYW5kIHRoaXMgcG9seWZpbGwgbmVlZCB0byB3b3JrIG9uIHRvcCBvZiB1bmZldGNoXG4gICAgLy8gc28gdGhlIGJlbG93IGZlYXR1cmUgZGV0ZWN0aW9uIG5lZWRzIHRoZSAhc2VsZi5BYm9ydENvbnRyb2xsZXIgcGFydC5cbiAgICAvLyBUaGUgUmVxdWVzdC5wcm90b3R5cGUgY2hlY2sgaXMgYWxzbyBuZWVkZWQgYmVjYXVzZSBTYWZhcmkgdmVyc2lvbnMgMTEuMS4yXG4gICAgLy8gdXAgdG8gYW5kIGluY2x1ZGluZyAxMi4xLnggaGFzIGEgd2luZG93LkFib3J0Q29udHJvbGxlciBwcmVzZW50IGJ1dCBzdGlsbFxuICAgIC8vIGRvZXMgTk9UIGNvcnJlY3RseSBpbXBsZW1lbnQgYWJvcnRhYmxlIGZldGNoOlxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzQ5ODAjYzJcblxuXG4gICAgcmV0dXJuIHR5cGVvZiBzZWxmLlJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgIXNlbGYuUmVxdWVzdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3NpZ25hbCcpIHx8ICFzZWxmLkFib3J0Q29udHJvbGxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlOiB0aGUgXCJmZXRjaC5SZXF1ZXN0XCIgZGVmYXVsdCB2YWx1ZSBpcyBhdmFpbGFibGUgZm9yIGZldGNoIGltcG9ydGVkIGZyb21cbiAgICogdGhlIFwibm9kZS1mZXRjaFwiIHBhY2thZ2UgYW5kIG5vdCBpbiBicm93c2Vycy4gVGhpcyBpcyBPSyBzaW5jZSBicm93c2Vyc1xuICAgKiB3aWxsIGJlIGltcG9ydGluZyB1bWQtcG9seWZpbGwuanMgZnJvbSB0aGF0IHBhdGggXCJzZWxmXCIgaXMgcGFzc2VkIHRoZVxuICAgKiBkZWNvcmF0b3Igc28gdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBub3QgYmUgdXNlZCAoYmVjYXVzZSBicm93c2VycyB0aGF0IGRlZmluZVxuICAgKiBmZXRjaCBhbHNvIGhhcyBSZXF1ZXN0KS4gT25lIHF1aXJreSBzZXR1cCB3aGVyZSBzZWxmLmZldGNoIGV4aXN0cyBidXRcbiAgICogc2VsZi5SZXF1ZXN0IGRvZXMgbm90IGlzIHdoZW4gdGhlIFwidW5mZXRjaFwiIG1pbmltYWwgZmV0Y2ggcG9seWZpbGwgaXMgdXNlZFxuICAgKiBvbiB0b3Agb2YgSUUxMTsgZm9yIHRoaXMgY2FzZSB0aGUgYnJvd3NlciB3aWxsIHRyeSB0byB1c2UgdGhlIGZldGNoLlJlcXVlc3RcbiAgICogZGVmYXVsdCB2YWx1ZSB3aGljaCBpbiB0dXJuIHdpbGwgYmUgdW5kZWZpbmVkIGJ1dCB0aGVuIHRoZW4gXCJpZiAoUmVxdWVzdClcIlxuICAgKiB3aWxsIGVuc3VyZSB0aGF0IHlvdSBnZXQgYSBwYXRjaGVkIGZldGNoIGJ1dCBzdGlsbCBubyBSZXF1ZXN0IChhcyBleHBlY3RlZCkuXG4gICAqIEBwYXJhbSB7ZmV0Y2gsIFJlcXVlc3QgPSBmZXRjaC5SZXF1ZXN0fVxuICAgKiBAcmV0dXJucyB7ZmV0Y2g6IGFib3J0YWJsZUZldGNoLCBSZXF1ZXN0OiBBYm9ydGFibGVSZXF1ZXN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaERlY29yYXRvcihwYXRjaFRhcmdldHMpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHBhdGNoVGFyZ2V0cykge1xuICAgICAgcGF0Y2hUYXJnZXRzID0ge1xuICAgICAgICBmZXRjaDogcGF0Y2hUYXJnZXRzXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBfcGF0Y2hUYXJnZXRzID0gcGF0Y2hUYXJnZXRzLFxuICAgICAgICBmZXRjaCA9IF9wYXRjaFRhcmdldHMuZmV0Y2gsXG4gICAgICAgIF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMuUmVxdWVzdCxcbiAgICAgICAgTmF0aXZlUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9PT0gdm9pZCAwID8gZmV0Y2guUmVxdWVzdCA6IF9wYXRjaFRhcmdldHMkUmVxdWVzdCxcbiAgICAgICAgTmF0aXZlQWJvcnRDb250cm9sbGVyID0gX3BhdGNoVGFyZ2V0cy5BYm9ydENvbnRyb2xsZXIsXG4gICAgICAgIF9wYXRjaFRhcmdldHMkX19GT1JDRSA9IF9wYXRjaFRhcmdldHMuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCxcbiAgICAgICAgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCA9IF9wYXRjaFRhcmdldHMkX19GT1JDRSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0U7XG5cbiAgICBpZiAoIXBvbHlmaWxsTmVlZGVkKHtcbiAgICAgIGZldGNoOiBmZXRjaCxcbiAgICAgIFJlcXVlc3Q6IE5hdGl2ZVJlcXVlc3QsXG4gICAgICBBYm9ydENvbnRyb2xsZXI6IE5hdGl2ZUFib3J0Q29udHJvbGxlcixcbiAgICAgIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEw6IF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTExcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmV0Y2g6IGZldGNoLFxuICAgICAgICBSZXF1ZXN0OiBSZXF1ZXN0XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBSZXF1ZXN0ID0gTmF0aXZlUmVxdWVzdDsgLy8gTm90ZSB0aGF0IHRoZSBcInVuZmV0Y2hcIiBtaW5pbWFsIGZldGNoIHBvbHlmaWxsIGRlZmluZXMgZmV0Y2goKSB3aXRob3V0XG4gICAgLy8gZGVmaW5pbmcgd2luZG93LlJlcXVlc3QsIGFuZCB0aGlzIHBvbHlmaWxsIG5lZWQgdG8gd29yayBvbiB0b3Agb2YgdW5mZXRjaFxuICAgIC8vIGhlbmNlIHdlIG9ubHkgcGF0Y2ggaXQgaWYgaXQncyBhdmFpbGFibGUuIEFsc28gd2UgZG9uJ3QgcGF0Y2ggaXQgaWYgc2lnbmFsXG4gICAgLy8gaXMgYWxyZWFkeSBhdmFpbGFibGUgb24gdGhlIFJlcXVlc3QgcHJvdG90eXBlIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHN1cHBvcnRcbiAgICAvLyBpcyBwcmVzZW50IGFuZCB0aGUgcGF0Y2hpbmcgYmVsb3cgY2FuIGNhdXNlIGEgY3Jhc2ggc2luY2UgaXQgYXNzaWducyB0b1xuICAgIC8vIHJlcXVlc3Quc2lnbmFsIHdoaWNoIGlzIHRlY2huaWNhbGx5IGEgcmVhZC1vbmx5IHByb3BlcnR5LiBUaGlzIGxhdHRlciBlcnJvclxuICAgIC8vIGhhcHBlbnMgd2hlbiB5b3UgcnVuIHRoZSBtYWluNS5qcyBub2RlLWZldGNoIGV4YW1wbGUgaW4gdGhlIHJlcG9cbiAgICAvLyBcImFib3J0Y29udHJvbGxlci1wb2x5ZmlsbC1leGFtcGxlc1wiLiBUaGUgZXhhY3QgZXJyb3IgaXM6XG4gICAgLy8gICByZXF1ZXN0LnNpZ25hbCA9IGluaXQuc2lnbmFsO1xuICAgIC8vICAgXlxuICAgIC8vIFR5cGVFcnJvcjogQ2Fubm90IHNldCBwcm9wZXJ0eSBzaWduYWwgb2YgIzxSZXF1ZXN0PiB3aGljaCBoYXMgb25seSBhIGdldHRlclxuXG4gICAgaWYgKFJlcXVlc3QgJiYgIVJlcXVlc3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzaWduYWwnKSB8fCBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7XG4gICAgICBSZXF1ZXN0ID0gZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgaW5pdCkge1xuICAgICAgICB2YXIgc2lnbmFsO1xuXG4gICAgICAgIGlmIChpbml0ICYmIGluaXQuc2lnbmFsKSB7XG4gICAgICAgICAgc2lnbmFsID0gaW5pdC5zaWduYWw7IC8vIE5ldmVyIHBhc3MgaW5pdC5zaWduYWwgdG8gdGhlIG5hdGl2ZSBSZXF1ZXN0IGltcGxlbWVudGF0aW9uIHdoZW4gdGhlIHBvbHlmaWxsIGhhc1xuICAgICAgICAgIC8vIGJlZW4gaW5zdGFsbGVkIGJlY2F1c2UgaWYgd2UncmUgcnVubmluZyBvbiB0b3Agb2YgYSBicm93c2VyIHdpdGggYVxuICAgICAgICAgIC8vIHdvcmtpbmcgbmF0aXZlIEFib3J0Q29udHJvbGxlciAoaS5lLiB0aGUgcG9seWZpbGwgd2FzIGluc3RhbGxlZCBkdWUgdG9cbiAgICAgICAgICAvLyBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMIGJlaW5nIHNldCksIHRoZW4gcGFzc2luZyBvdXJcbiAgICAgICAgICAvLyBmYWtlIEFib3J0U2lnbmFsIHRvIHRoZSBuYXRpdmUgZmV0Y2ggd2lsbCB0cmlnZ2VyOlxuICAgICAgICAgIC8vIFR5cGVFcnJvcjogRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IG1lbWJlciBzaWduYWwgaXMgbm90IG9mIHR5cGUgQWJvcnRTaWduYWwuXG5cbiAgICAgICAgICBkZWxldGUgaW5pdC5zaWduYWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBOYXRpdmVSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVlc3QsICdzaWduYWwnLCB7XG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBzaWduYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgfTtcblxuICAgICAgUmVxdWVzdC5wcm90b3R5cGUgPSBOYXRpdmVSZXF1ZXN0LnByb3RvdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgcmVhbEZldGNoID0gZmV0Y2g7XG5cbiAgICB2YXIgYWJvcnRhYmxlRmV0Y2ggPSBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaChpbnB1dCwgaW5pdCkge1xuICAgICAgdmFyIHNpZ25hbCA9IFJlcXVlc3QgJiYgUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBpbml0ID8gaW5pdC5zaWduYWwgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgdmFyIGFib3J0RXJyb3I7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIElFIDExIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZyB0aGUgRE9NRXhjZXB0aW9uIGNvbnN0cnVjdG9yLCB1c2UgYVxuICAgICAgICAgIC8vIHJlZ3VsYXIgZXJyb3Igb2JqZWN0IG9uIGl0IGluc3RlYWQuXG4gICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgICAgIGFib3J0RXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICAgICAgfSAvLyBSZXR1cm4gZWFybHkgaWYgYWxyZWFkeSBhYm9ydGVkLCB0aHVzIGF2b2lkaW5nIG1ha2luZyBhbiBIVFRQIHJlcXVlc3RcblxuXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTtcbiAgICAgICAgfSAvLyBUdXJuIGFuIGV2ZW50IGludG8gYSBwcm9taXNlLCByZWplY3QgaXQgb25jZSBgYWJvcnRgIGlzIGRpc3BhdGNoZWRcblxuXG4gICAgICAgIHZhciBjYW5jZWxsYXRpb24gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChhYm9ydEVycm9yKTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbml0ICYmIGluaXQuc2lnbmFsKSB7XG4gICAgICAgICAgLy8gTmV2ZXIgcGFzcyAuc2lnbmFsIHRvIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gd2hlbiB0aGUgcG9seWZpbGwgaGFzXG4gICAgICAgICAgLy8gYmVlbiBpbnN0YWxsZWQgYmVjYXVzZSBpZiB3ZSdyZSBydW5uaW5nIG9uIHRvcCBvZiBhIGJyb3dzZXIgd2l0aCBhXG4gICAgICAgICAgLy8gd29ya2luZyBuYXRpdmUgQWJvcnRDb250cm9sbGVyIChpLmUuIHRoZSBwb2x5ZmlsbCB3YXMgaW5zdGFsbGVkIGR1ZSB0b1xuICAgICAgICAgIC8vIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwgYmVpbmcgc2V0KSwgdGhlbiBwYXNzaW5nIG91clxuICAgICAgICAgIC8vIGZha2UgQWJvcnRTaWduYWwgdG8gdGhlIG5hdGl2ZSBmZXRjaCB3aWxsIHRyaWdnZXI6XG4gICAgICAgICAgLy8gVHlwZUVycm9yOiBGYWlsZWQgdG8gZXhlY3V0ZSAnZmV0Y2gnIG9uICdXaW5kb3cnOiBtZW1iZXIgc2lnbmFsIGlzIG5vdCBvZiB0eXBlIEFib3J0U2lnbmFsLlxuICAgICAgICAgIGRlbGV0ZSBpbml0LnNpZ25hbDtcbiAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGZhc3Rlc3QgcHJvbWlzZSAoZG9uJ3QgbmVlZCB0byB3YWl0IGZvciByZXF1ZXN0IHRvIGZpbmlzaClcblxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvbiwgcmVhbEZldGNoKGlucHV0LCBpbml0KV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhbEZldGNoKGlucHV0LCBpbml0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZldGNoOiBhYm9ydGFibGVGZXRjaCxcbiAgICAgIFJlcXVlc3Q6IFJlcXVlc3RcbiAgICB9O1xuICB9XG5cbiAgKGZ1bmN0aW9uIChzZWxmKSB7XG5cbiAgICBpZiAoIXBvbHlmaWxsTmVlZGVkKHNlbGYpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLmZldGNoKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2ZldGNoKCkgaXMgbm90IGF2YWlsYWJsZSwgY2Fubm90IGluc3RhbGwgYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9hYm9ydGFibGVGZXRjaCA9IGFib3J0YWJsZUZldGNoRGVjb3JhdG9yKHNlbGYpLFxuICAgICAgICBmZXRjaCA9IF9hYm9ydGFibGVGZXRjaC5mZXRjaCxcbiAgICAgICAgUmVxdWVzdCA9IF9hYm9ydGFibGVGZXRjaC5SZXF1ZXN0O1xuXG4gICAgc2VsZi5mZXRjaCA9IGZldGNoO1xuICAgIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsICdBYm9ydENvbnRyb2xsZXInLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IEFib3J0Q29udHJvbGxlclxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCAnQWJvcnRTaWduYWwnLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IEFib3J0U2lnbmFsXG4gICAgfSk7XG4gIH0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiBnbG9iYWwpO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3NDk4MFxuaW1wb3J0ICdhYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9wb2x5ZmlsbC1wYXRjaC1mZXRjaCc7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZG9tL3B1bGwvNDY3XG5pbXBvcnQge0V2ZW50VGFyZ2V0fSBmcm9tICdldmVudC10YXJnZXQtc2hpbSc7XG50cnkge1xuXHRuZXcgd2luZG93LkV2ZW50VGFyZ2V0KCk7XG59IGNhdGNoIChlcnJvcikge1xuXHR3aW5kb3cuRXZlbnRUYXJnZXQgPSBFdmVudFRhcmdldDtcbn1cbiIsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqZ0JBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNWQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUtBO0FBQ0E7QUFEQTtBQUpBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUdBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUNySkE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQ3JDQTtBQUdBO0FBQ0E7QUFEQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkVBO0FBU0E7QUFDQTtBQURBO0FBUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxREE7QUFPQTtBQUFBO0FBTkE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQWdCQTtBQVFBO0FBdkJBO0FBRUE7QUFRQTtBQUVBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTs7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuTkE7QUFBQTtBQVVBO0FBQ0E7QUFpQ0E7QUEzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQzNDQTtBQUFBO0FBUUE7QUFzQkE7QUE3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/naja/dist/Naja.esm.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz83NjZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/OTg1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ })

/******/ });
//# sourceMappingURL=dev.bundle.main.js.map